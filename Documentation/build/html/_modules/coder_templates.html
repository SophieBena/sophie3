<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>coder_templates &mdash; Thermoengine 1.0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../None"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="Thermoengine 1.0.1 documentation" href="../index.html" >
    <link rel="up" title="Module code" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="ENKI" src="../_static/img/ENKI_header.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="http://enki-portal.org">ENKI Web</a></li>
        <li class="active"><a href="https://enki.ofm-research.org">ENKI Server</a></li>
	
        <li class="active"><a href="../index.html">Thermoengine 1.0.1 documentation</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Enki.png" alt="Logo">
            </a></p>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for coder_templates</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">The Coder Templates module provides templates that suport code generation in coder.py classes.</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;create_calib_c_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_calib_h_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_calib_pyx_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_code_for_born_functions&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_code_for_debye_function&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_code_for_dh_functions&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_fast_c_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_fast_h_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_fast_pyx_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_pyxbld_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_redundant_calib_TV_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_redundant_function_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calc_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calib_code_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calib_extra_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calib_include_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calib_pyx_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_calib_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_deriv_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_fast_code_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_fast_include_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_fast_pyx_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_pyxbld_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_redun_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_soln_std_state_include_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_ordering_gaussj_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_ordering_code_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_complx_soln_calc_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_complx_soln_calib_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_speciation_code_template&#39;</span><span class="p">,</span>
           <span class="s1">&#39;create_speciation_ordering_code_template&#39;</span>
           <span class="p">]</span>

<span class="c1">##############################</span>
<span class="c1"># Generic External Functions #</span>
<span class="c1">##############################</span>

<div class="viewcode-block" id="create_calib_c_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_calib_c_template">[docs]</a><span class="k">def</span> <span class="nf">create_calib_c_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for a C function file that implements calibration</span>
<span class="sd">    mode calculation of model functions for a specific phase instance.</span>

<span class="sd">    The calibration functions expose the model parameters using getters and</span>
<span class="sd">    setters, which otherwise are fixed as constants in the *fast* routines,</span>
<span class="sd">    allowing the compiler to optimize the resulting code.</span>

<span class="sd">    The user does not normally call this function directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_c_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_c_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_calib_h_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_calib_h_template">[docs]</a><span class="k">def</span> <span class="nf">create_calib_h_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for an include file that implements calibration mode</span>
<span class="sd">    calculation of model functions for a specific phase instance.</span>

<span class="sd">    The calibration functions expose the model parameters using getters and</span>
<span class="sd">    setters, which otherwise are fixed as constants in the *fast* routines,</span>
<span class="sd">    allowing the compiler to optimize the resulting code.</span>

<span class="sd">    The user does not normally call this function directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_h_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_h_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_calib_pyx_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_calib_pyx_template">[docs]</a><span class="k">def</span> <span class="nf">create_calib_pyx_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves calib code template for cython pyx file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_pyx_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_calib_pyx_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_code_for_born_functions"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_code_for_born_functions">[docs]</a><span class="k">def</span> <span class="nf">create_code_for_born_functions</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves code that provides a reference to the Born functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_born_functions_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_born_functions_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_code_for_debye_function"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_code_for_debye_function">[docs]</a><span class="k">def</span> <span class="nf">create_code_for_debye_function</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves a block of code that provides an implementation of the Debye</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_debye_function_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_debye_function_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_code_for_dh_functions"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_code_for_dh_functions">[docs]</a><span class="k">def</span> <span class="nf">create_code_for_dh_functions</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves code that provides a reference to the Debye-Hückel</span>
<span class="sd">    solvent functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_dh_functions_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_code_for_dh_functions_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_fast_c_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_fast_c_template">[docs]</a><span class="k">def</span> <span class="nf">create_fast_c_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for a C function file that implements fast</span>
<span class="sd">    calculation of model functions for a specific phase instance.</span>

<span class="sd">    The user does not normally call this function directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_c_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_c_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_fast_h_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_fast_h_template">[docs]</a><span class="k">def</span> <span class="nf">create_fast_h_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for an include file that implements fast calculation</span>
<span class="sd">    of model functions for a specific phase instance.</span>

<span class="sd">    The user does not normally call this function directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_h_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_h_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_fast_pyx_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_fast_pyx_template">[docs]</a><span class="k">def</span> <span class="nf">create_fast_pyx_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves fast code template for cython pyx file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_pyx_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_fast_pyx_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_pyxbld_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_pyxbld_template">[docs]</a><span class="k">def</span> <span class="nf">create_pyxbld_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for cython pyxbld file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_pyxbld_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_pyxbld_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_redundant_calib_TV_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_redundant_calib_TV_template">[docs]</a><span class="k">def</span> <span class="nf">create_redundant_calib_TV_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for redundant thermodynamic functions associated with</span>
<span class="sd">    Helmholtz models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_redundant_calib_TV_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_redundant_calib_TV_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_redundant_function_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_redundant_function_template">[docs]</a><span class="k">def</span> <span class="nf">create_redundant_function_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;TP&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for redundant thermodynamic functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>
<span class="sd">    model_type: string</span>
<span class="sd">        Potential type, either Gibbs free energy (&#39;TP&#39;) or Helmholtz free</span>
<span class="sd">        energy (&#39;TV&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_redundant_function_template_c</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="n">model_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_redundant_function_template_cpp</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="n">model_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calc_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calc_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calc_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for solution functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calc_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calc_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calib_code_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calib_code_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calib_code_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for calibration code solution template.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_code_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_code_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calib_extra_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calib_extra_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calib_extra_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for solution calibration functions that retrieve and set</span>
<span class="sd">    values of model parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_extra_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_extra_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calib_include_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calib_include_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calib_include_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for calibration include file solution template.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_include_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_include_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calib_pyx_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calib_pyx_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calib_pyx_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves calib solution code template for cython pyx file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_pyx_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_pyx_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_calib_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_calib_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_calib_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for solution calibration functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_calib_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_deriv_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_deriv_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_deriv_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for solution derivative functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_deriv_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_deriv_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_fast_code_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_fast_code_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_fast_code_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for fast code solution template.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_code_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_code_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_fast_include_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_fast_include_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_fast_include_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for fast include file solution template.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_include_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_include_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_fast_pyx_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_fast_pyx_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_fast_pyx_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves fast solution code template for cython pyx file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_pyx_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_fast_pyx_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_pyxbld_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_pyxbld_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_pyxbld_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for cython solution pyxbld file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_pyxbld_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_pyxbld_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_redun_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_redun_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_redun_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for solution redundant functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_redun_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_redun_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_soln_std_state_include_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_soln_std_state_include_template">[docs]</a><span class="k">def</span> <span class="nf">create_soln_std_state_include_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for standard state properties include template.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_std_state_include_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_soln_std_state_include_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_ordering_gaussj_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_ordering_gaussj_template">[docs]</a><span class="k">def</span> <span class="nf">create_ordering_gaussj_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of guassj code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_ordering_gaussj_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_ordering_gaussj_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_ordering_code_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_ordering_code_template">[docs]</a><span class="k">def</span> <span class="nf">create_ordering_code_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of ordering code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_ordering_code_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_ordering_code_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_complx_soln_calc_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_complx_soln_calc_template">[docs]</a><span class="k">def</span> <span class="nf">create_complx_soln_calc_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of solution property code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_complx_soln_calc_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_complx_soln_calc_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_complx_soln_calib_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_complx_soln_calib_template">[docs]</a><span class="k">def</span> <span class="nf">create_complx_soln_calib_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of solution property code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_complx_soln_calib_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_complx_soln_calib_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_speciation_code_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_speciation_code_template">[docs]</a><span class="k">def</span> <span class="nf">create_speciation_code_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of speciation code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_speciation_code_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_speciation_code_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="create_speciation_ordering_code_template"><a class="viewcode-back" href="../coder_templates.html#coder_templates.create_speciation_ordering_code_template">[docs]</a><span class="k">def</span> <span class="nf">create_speciation_ordering_code_template</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves template for generation of speciation ordering code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    language : string</span>
<span class="sd">        Language syntax for generated code, (&quot;C&quot; is the C99 programming</span>
<span class="sd">        language)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_speciation_ordering_code_template_c</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">language</span> <span class="o">==</span> <span class="s1">&#39;C++&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_create_speciation_ordering_code_template_cpp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Language not implemented.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<span class="c1">##############################</span>
<span class="c1"># Standard State C templates #</span>
<span class="c1">##############################</span>

<span class="k">def</span> <span class="nf">_create_calib_c_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_calib_c_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static char *identifier = &quot;</span><span class="si">{git_identifier}</span><span class="s2">&quot;;</span>
<span class="si">{parameter_init_block}</span><span class="s2"></span>

<span class="si">{include_calc_h}</span><span class="s2"></span>
<span class="si">{include_calib_h}</span><span class="s2"></span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier(void) {{</span>
<span class="s2">    return identifier;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{phase}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{formula}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_mw(void) {{</span>
<span class="s2">    return </span><span class="si">{mw}</span><span class="s2">;</span>
<span class="s2">}}</span>

<span class="s2">static const double elmformula[106] = {{</span>
<span class="s2">        </span><span class="si">{elmvector[0]}</span><span class="s2">,</span><span class="si">{elmvector[1]}</span><span class="s2">,</span><span class="si">{elmvector[2]}</span><span class="s2">,</span><span class="si">{elmvector[3]}</span><span class="s2">,</span><span class="si">{elmvector[4]}</span><span class="s2">,</span><span class="si">{elmvector[5]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[6]}</span><span class="s2">,</span><span class="si">{elmvector[7]}</span><span class="s2">,</span><span class="si">{elmvector[8]}</span><span class="s2">,</span><span class="si">{elmvector[9]}</span><span class="s2">,</span><span class="si">{elmvector[10]}</span><span class="s2">,</span><span class="si">{elmvector[11]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[12]}</span><span class="s2">,</span><span class="si">{elmvector[13]}</span><span class="s2">,</span><span class="si">{elmvector[14]}</span><span class="s2">,</span><span class="si">{elmvector[15]}</span><span class="s2">,</span><span class="si">{elmvector[16]}</span><span class="s2">,</span><span class="si">{elmvector[17]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[18]}</span><span class="s2">,</span><span class="si">{elmvector[19]}</span><span class="s2">,</span><span class="si">{elmvector[20]}</span><span class="s2">,</span><span class="si">{elmvector[21]}</span><span class="s2">,</span><span class="si">{elmvector[22]}</span><span class="s2">,</span><span class="si">{elmvector[23]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[24]}</span><span class="s2">,</span><span class="si">{elmvector[25]}</span><span class="s2">,</span><span class="si">{elmvector[26]}</span><span class="s2">,</span><span class="si">{elmvector[27]}</span><span class="s2">,</span><span class="si">{elmvector[28]}</span><span class="s2">,</span><span class="si">{elmvector[29]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[30]}</span><span class="s2">,</span><span class="si">{elmvector[31]}</span><span class="s2">,</span><span class="si">{elmvector[32]}</span><span class="s2">,</span><span class="si">{elmvector[33]}</span><span class="s2">,</span><span class="si">{elmvector[34]}</span><span class="s2">,</span><span class="si">{elmvector[35]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[36]}</span><span class="s2">,</span><span class="si">{elmvector[37]}</span><span class="s2">,</span><span class="si">{elmvector[38]}</span><span class="s2">,</span><span class="si">{elmvector[39]}</span><span class="s2">,</span><span class="si">{elmvector[40]}</span><span class="s2">,</span><span class="si">{elmvector[41]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[42]}</span><span class="s2">,</span><span class="si">{elmvector[43]}</span><span class="s2">,</span><span class="si">{elmvector[44]}</span><span class="s2">,</span><span class="si">{elmvector[45]}</span><span class="s2">,</span><span class="si">{elmvector[46]}</span><span class="s2">,</span><span class="si">{elmvector[47]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[48]}</span><span class="s2">,</span><span class="si">{elmvector[49]}</span><span class="s2">,</span><span class="si">{elmvector[50]}</span><span class="s2">,</span><span class="si">{elmvector[51]}</span><span class="s2">,</span><span class="si">{elmvector[52]}</span><span class="s2">,</span><span class="si">{elmvector[53]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[54]}</span><span class="s2">,</span><span class="si">{elmvector[55]}</span><span class="s2">,</span><span class="si">{elmvector[56]}</span><span class="s2">,</span><span class="si">{elmvector[57]}</span><span class="s2">,</span><span class="si">{elmvector[58]}</span><span class="s2">,</span><span class="si">{elmvector[59]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[60]}</span><span class="s2">,</span><span class="si">{elmvector[61]}</span><span class="s2">,</span><span class="si">{elmvector[62]}</span><span class="s2">,</span><span class="si">{elmvector[63]}</span><span class="s2">,</span><span class="si">{elmvector[64]}</span><span class="s2">,</span><span class="si">{elmvector[65]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[66]}</span><span class="s2">,</span><span class="si">{elmvector[67]}</span><span class="s2">,</span><span class="si">{elmvector[68]}</span><span class="s2">,</span><span class="si">{elmvector[69]}</span><span class="s2">,</span><span class="si">{elmvector[70]}</span><span class="s2">,</span><span class="si">{elmvector[71]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[72]}</span><span class="s2">,</span><span class="si">{elmvector[73]}</span><span class="s2">,</span><span class="si">{elmvector[74]}</span><span class="s2">,</span><span class="si">{elmvector[75]}</span><span class="s2">,</span><span class="si">{elmvector[76]}</span><span class="s2">,</span><span class="si">{elmvector[77]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[78]}</span><span class="s2">,</span><span class="si">{elmvector[79]}</span><span class="s2">,</span><span class="si">{elmvector[80]}</span><span class="s2">,</span><span class="si">{elmvector[81]}</span><span class="s2">,</span><span class="si">{elmvector[82]}</span><span class="s2">,</span><span class="si">{elmvector[83]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[84]}</span><span class="s2">,</span><span class="si">{elmvector[85]}</span><span class="s2">,</span><span class="si">{elmvector[86]}</span><span class="s2">,</span><span class="si">{elmvector[87]}</span><span class="s2">,</span><span class="si">{elmvector[88]}</span><span class="s2">,</span><span class="si">{elmvector[89]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[90]}</span><span class="s2">,</span><span class="si">{elmvector[91]}</span><span class="s2">,</span><span class="si">{elmvector[92]}</span><span class="s2">,</span><span class="si">{elmvector[93]}</span><span class="s2">,</span><span class="si">{elmvector[94]}</span><span class="s2">,</span><span class="si">{elmvector[95]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[96]}</span><span class="s2">,</span><span class="si">{elmvector[97]}</span><span class="s2">,</span><span class="si">{elmvector[98]}</span><span class="s2">,</span><span class="si">{elmvector[99]}</span><span class="s2">,</span><span class="si">{elmvector[100]}</span><span class="s2">,</span><span class="si">{elmvector[101]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[102]}</span><span class="s2">,</span><span class="si">{elmvector[103]}</span><span class="s2">,</span><span class="si">{elmvector[104]}</span><span class="s2">,</span><span class="si">{elmvector[105]}</span><span class="s2"></span>
<span class="s2">    }};</span>

<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_elements(void) {{</span>
<span class="s2">    return elmformula;</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_g(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdt(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_s(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_v(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cv(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dcpdt(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_alpha(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_beta(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_K(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_Kp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_number();</span>
<span class="s2">}}</span>

<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_names();</span>
<span class="s2">}}</span>

<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_units();</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_get_param_values(values);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_set_param_values(values);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_value(index);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_set_param_value(index, value);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_g(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_dgdt(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_dgdp(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(T, P, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double T, double P, int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(T, P, index);</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_calib_h_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_calib_h_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(void);</span>
<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_mw(void);</span>
<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_elements(void);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double T, double P);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double T, double P);</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number(void);</span>
<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names(void);</span>
<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units(void);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double T, double P, int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double T, double P, int index);</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_calib_pyx_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_calib_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2"># Cython numpy wrapper code for arrays is taken from:</span>
<span class="s2"># http://gael-varoquaux.info/programming/cython-example-of-exposing-c-computed-arrays-in-python-without-data-copies.html</span>
<span class="s2"># Author: Gael Varoquaux, BSD license</span>

<span class="s2"># Declare the prototype of the C functions</span>
<span class="s2">cdef extern from &quot;</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib.h&quot;:</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula();</span>
<span class="s2">    const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_mw();</span>
<span class="s2">    const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_elements();</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double t, double p);</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number();</span>
<span class="s2">    const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names();</span>
<span class="s2">    const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units();</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values);</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index);</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double t, double p, int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double t, double p, int index);</span>

<span class="s2">from libc.stdlib cimport malloc, free</span>
<span class="s2">from cpython cimport PyObject, Py_INCREF</span>
<span class="s2">import ctypes</span>

<span class="s2"># Import the Python-level symbols of numpy</span>
<span class="s2">import numpy as np</span>

<span class="s2"># Import the C-level symbols of numpy</span>
<span class="s2">cimport numpy as np</span>

<span class="s2"># Numpy must be initialized. When using numpy from C or Cython you must</span>
<span class="s2"># _always_ do that, or you will have segfaults</span>
<span class="s2">np.import_array()</span>

<span class="s2"># here is the &quot;wrapper&quot; signature</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_mw():</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_mw()</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_elements():</span>
<span class="s2">    cdef const double *e = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_elements()</span>
<span class="s2">    np_array = np.zeros(106)</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        np_array[i] = e[i]</span>
<span class="s2">    return np_array</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number():</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names():</span>
<span class="s2">    cdef const char **names = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names()</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,n):</span>
<span class="s2">        entry = &lt;bytes&gt; names[i]</span>
<span class="s2">        result.append(entry.decode(&#39;UTF-8&#39;))</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units():</span>
<span class="s2">    cdef const char **units = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units()</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,n):</span>
<span class="s2">        entry = &lt;bytes&gt; units[i]</span>
<span class="s2">        result.append(entry.decode(&#39;UTF-8&#39;))</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values():</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(n*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(&amp;m)</span>
<span class="s2">    np_array = np.zeros(n)</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        np_array[i] = m[i]</span>
<span class="s2">    free(m)</span>
<span class="s2">    return np_array</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(np_array):</span>
<span class="s2">    n = len(np_array)</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(n*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(m);</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(&lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(&lt;int&gt; index, &lt;double&gt; value)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double t, double p, int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(&lt;double&gt; t, &lt;double&gt; p, &lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_born_functions_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_code_for_born_functions()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">double born_B(double t, double p);</span>
<span class="s2">double born_Q(double t, double p);</span>
<span class="s2">double born_N(double t, double p);</span>
<span class="s2">double born_U(double t, double p);</span>
<span class="s2">double born_Y(double t, double p);</span>
<span class="s2">double born_X(double t, double p);</span>
<span class="s2">double born_dUdT(double t, double p);</span>
<span class="s2">double born_dUdP(double t, double p);</span>
<span class="s2">double born_dNdT(double t, double p);</span>
<span class="s2">double born_dNdP(double t, double p);</span>
<span class="s2">double born_dXdT(double t, double p);</span>
<span class="s2">double gSolvent(double t, double p);</span>
<span class="s2">double DgSolventDt(double t, double p);</span>
<span class="s2">double DgSolventDp(double t, double p);</span>
<span class="s2">double D2gSolventDt2(double t, double p);</span>
<span class="s2">double D2gSolventDtDp(double t, double p);</span>
<span class="s2">double D2gSolventDp2(double t, double p);</span>
<span class="s2">double D3gSolventDt3(double t, double p);</span>
<span class="s2">double D3gSolventDt2Dp(double t, double p);</span>
<span class="s2">double D3gSolventDtDp2(double t, double p);</span>
<span class="s2">double D3gSolventDp3(double t, double p);</span>
<span class="s2">double D4gSolventDt4(double t, double p);</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_debye_function_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_code_for_debye_function()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#include &lt;float.h&gt;</span>

<span class="s2">static double chebvalat(double x) {</span>
<span class="s2">    double c[17] = {</span>
<span class="s2">        2.707737068327440945 / 2.0, 0.340068135211091751, -0.12945150184440869e-01, 0.7963755380173816e-03,</span>
<span class="s2">        -0.546360009590824e-04, 0.39243019598805e-05, -0.2894032823539e-06, 0.217317613962e-07, -0.16542099950e-08,</span>
<span class="s2">        0.1272796189e-09, -0.987963460e-11, 0.7725074e-12, -0.607797e-13, 0.48076e-14, -0.3820e-15, 0.305e-16, -0.24e-17</span>
<span class="s2">    };</span>
<span class="s2">    double x2 = 2 * x;</span>
<span class="s2">    double c0 = c[17-2];</span>
<span class="s2">    double c1 = c[17-1];</span>
<span class="s2">    for (int i=3; i&lt;18; i++) {</span>
<span class="s2">        double tmp = c0;</span>
<span class="s2">        c0 = c[17-i] - c1;</span>
<span class="s2">        c1 = tmp + c1 * x2;</span>
<span class="s2">    }</span>
<span class="s2">    return c0 + c1 * x;</span>
<span class="s2">}</span>

<span class="s2">static double Debye(double x) {</span>
<span class="s2">    double val_infinity = 19.4818182068004875;</span>
<span class="s2">    double sqrt_eps = sqrt(DBL_EPSILON);</span>
<span class="s2">    double log_eps = log(DBL_EPSILON);</span>
<span class="s2">    double xcut = -log_eps;</span>

<span class="s2">    if (x &lt;= 0.0) return 0.0;</span>

<span class="s2">    if (x &lt; (2.0*sqrt(2.0)*sqrt_eps)) return 1.0 - 3.0*x/8.0 + x*x/20.0;</span>
<span class="s2">    else if (x &lt;= 4.0) {</span>
<span class="s2">        double t = x*x/8.0 - 1.0;</span>
<span class="s2">        double c = chebvalat(t);</span>
<span class="s2">        return c - 0.375*x;</span>
<span class="s2">    } else if (x &lt; -(log(2.0)+log_eps)) {</span>
<span class="s2">        int nexp = (int)(floor(xcut / x));</span>
<span class="s2">        double ex = exp(-x);</span>
<span class="s2">        double xk = nexp * x;</span>
<span class="s2">        double rk = nexp;</span>
<span class="s2">        double sum = 0.0;</span>
<span class="s2">        for (int i=nexp; i&gt;0; i--) {</span>
<span class="s2">            double xk_inv = 1.0/xk;</span>
<span class="s2">            sum *= ex;</span>
<span class="s2">            sum += (((6.0*xk_inv + 6.0)*xk_inv + 3.0)*xk_inv + 1.0)/rk;</span>
<span class="s2">            rk -= 1.0;</span>
<span class="s2">            xk -= x;</span>
<span class="s2">        }</span>
<span class="s2">        return val_infinity / (x * x * x) - 3.0 * sum * ex;</span>
<span class="s2">    } else if (x &lt; xcut) {</span>
<span class="s2">        double x3 = x*x*x;</span>
<span class="s2">        double sum = 6.0 + 6.0*x + 3.0*x*x + x3;</span>
<span class="s2">        return (val_infinity - 3.0*sum*exp(-x))/x3;</span>
<span class="s2">    } else return ((val_infinity/x)/x)/x;</span>
<span class="s2">}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_dh_functions_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_code_for_dh_functions()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">double Agamma(double t, double p);</span>
<span class="s2">double dAgammaDt(double t, double p);</span>
<span class="s2">double dAgammaDp(double t, double p);</span>
<span class="s2">double d2AgammaDt2(double t, double p);</span>
<span class="s2">double d2AgammaDtDp(double t, double p);</span>
<span class="s2">double d2AgammaDp2(double t, double p);</span>
<span class="s2">double d3AgammaDt3(double t, double p);</span>
<span class="s2">double d3AgammaDt2Dp(double t, double p);</span>
<span class="s2">double d3AgammaDtDp2(double t, double p);</span>
<span class="s2">double d3AgammaDp3(double t, double p);</span>

<span class="s2">double Bgamma(double t, double p);</span>
<span class="s2">double dBgammaDt(double t, double p);</span>
<span class="s2">double dBgammaDp(double t, double p);</span>
<span class="s2">double d2BgammaDt2(double t, double p);</span>
<span class="s2">double d2BgammaDtDp(double t, double p);</span>
<span class="s2">double d2BgammaDp2(double t, double p);</span>
<span class="s2">double d3BgammaDt3(double t, double p);</span>
<span class="s2">double d3BgammaDt2Dp(double t, double p);</span>
<span class="s2">double d3BgammaDtDp2(double t, double p);</span>
<span class="s2">double d3BgammaDp3(double t, double p);</span>

<span class="s2">double AsubG(double t, double p);</span>
<span class="s2">double AsubH(double t, double p);</span>
<span class="s2">double AsubJ(double t, double p);</span>
<span class="s2">double AsubV(double t, double p);</span>
<span class="s2">double AsubKappa(double t, double p);</span>
<span class="s2">double AsubEx(double t, double p);</span>
<span class="s2">double BsubG(double t, double p);</span>
<span class="s2">double BsubH(double t, double p);</span>
<span class="s2">double BsubJ(double t, double p);</span>
<span class="s2">double BsubV(double t, double p);</span>
<span class="s2">double BsubKappa(double t, double p);</span>
<span class="s2">double BsubEx(double t, double p);</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_c_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_fast_c_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static const char *identifier = &quot;</span><span class="si">{git_identifier}</span><span class="s2">&quot;;</span>
<span class="si">{parameter_init_block}</span><span class="s2"></span>
<span class="si">{include_calc_h}</span><span class="s2"></span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier(void) {{</span>
<span class="s2">    return identifier;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{phase}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{formula}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_mw(void) {{</span>
<span class="s2">    return </span><span class="si">{mw}</span><span class="s2">;</span>
<span class="s2">}}</span>

<span class="s2">static const double elmformula[106] = {{</span>
<span class="s2">        </span><span class="si">{elmvector[0]}</span><span class="s2">,</span><span class="si">{elmvector[1]}</span><span class="s2">,</span><span class="si">{elmvector[2]}</span><span class="s2">,</span><span class="si">{elmvector[3]}</span><span class="s2">,</span><span class="si">{elmvector[4]}</span><span class="s2">,</span><span class="si">{elmvector[5]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[6]}</span><span class="s2">,</span><span class="si">{elmvector[7]}</span><span class="s2">,</span><span class="si">{elmvector[8]}</span><span class="s2">,</span><span class="si">{elmvector[9]}</span><span class="s2">,</span><span class="si">{elmvector[10]}</span><span class="s2">,</span><span class="si">{elmvector[11]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[12]}</span><span class="s2">,</span><span class="si">{elmvector[13]}</span><span class="s2">,</span><span class="si">{elmvector[14]}</span><span class="s2">,</span><span class="si">{elmvector[15]}</span><span class="s2">,</span><span class="si">{elmvector[16]}</span><span class="s2">,</span><span class="si">{elmvector[17]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[18]}</span><span class="s2">,</span><span class="si">{elmvector[19]}</span><span class="s2">,</span><span class="si">{elmvector[20]}</span><span class="s2">,</span><span class="si">{elmvector[21]}</span><span class="s2">,</span><span class="si">{elmvector[22]}</span><span class="s2">,</span><span class="si">{elmvector[23]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[24]}</span><span class="s2">,</span><span class="si">{elmvector[25]}</span><span class="s2">,</span><span class="si">{elmvector[26]}</span><span class="s2">,</span><span class="si">{elmvector[27]}</span><span class="s2">,</span><span class="si">{elmvector[28]}</span><span class="s2">,</span><span class="si">{elmvector[29]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[30]}</span><span class="s2">,</span><span class="si">{elmvector[31]}</span><span class="s2">,</span><span class="si">{elmvector[32]}</span><span class="s2">,</span><span class="si">{elmvector[33]}</span><span class="s2">,</span><span class="si">{elmvector[34]}</span><span class="s2">,</span><span class="si">{elmvector[35]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[36]}</span><span class="s2">,</span><span class="si">{elmvector[37]}</span><span class="s2">,</span><span class="si">{elmvector[38]}</span><span class="s2">,</span><span class="si">{elmvector[39]}</span><span class="s2">,</span><span class="si">{elmvector[40]}</span><span class="s2">,</span><span class="si">{elmvector[41]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[42]}</span><span class="s2">,</span><span class="si">{elmvector[43]}</span><span class="s2">,</span><span class="si">{elmvector[44]}</span><span class="s2">,</span><span class="si">{elmvector[45]}</span><span class="s2">,</span><span class="si">{elmvector[46]}</span><span class="s2">,</span><span class="si">{elmvector[47]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[48]}</span><span class="s2">,</span><span class="si">{elmvector[49]}</span><span class="s2">,</span><span class="si">{elmvector[50]}</span><span class="s2">,</span><span class="si">{elmvector[51]}</span><span class="s2">,</span><span class="si">{elmvector[52]}</span><span class="s2">,</span><span class="si">{elmvector[53]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[54]}</span><span class="s2">,</span><span class="si">{elmvector[55]}</span><span class="s2">,</span><span class="si">{elmvector[56]}</span><span class="s2">,</span><span class="si">{elmvector[57]}</span><span class="s2">,</span><span class="si">{elmvector[58]}</span><span class="s2">,</span><span class="si">{elmvector[59]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[60]}</span><span class="s2">,</span><span class="si">{elmvector[61]}</span><span class="s2">,</span><span class="si">{elmvector[62]}</span><span class="s2">,</span><span class="si">{elmvector[63]}</span><span class="s2">,</span><span class="si">{elmvector[64]}</span><span class="s2">,</span><span class="si">{elmvector[65]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[66]}</span><span class="s2">,</span><span class="si">{elmvector[67]}</span><span class="s2">,</span><span class="si">{elmvector[68]}</span><span class="s2">,</span><span class="si">{elmvector[69]}</span><span class="s2">,</span><span class="si">{elmvector[70]}</span><span class="s2">,</span><span class="si">{elmvector[71]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[72]}</span><span class="s2">,</span><span class="si">{elmvector[73]}</span><span class="s2">,</span><span class="si">{elmvector[74]}</span><span class="s2">,</span><span class="si">{elmvector[75]}</span><span class="s2">,</span><span class="si">{elmvector[76]}</span><span class="s2">,</span><span class="si">{elmvector[77]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[78]}</span><span class="s2">,</span><span class="si">{elmvector[79]}</span><span class="s2">,</span><span class="si">{elmvector[80]}</span><span class="s2">,</span><span class="si">{elmvector[81]}</span><span class="s2">,</span><span class="si">{elmvector[82]}</span><span class="s2">,</span><span class="si">{elmvector[83]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[84]}</span><span class="s2">,</span><span class="si">{elmvector[85]}</span><span class="s2">,</span><span class="si">{elmvector[86]}</span><span class="s2">,</span><span class="si">{elmvector[87]}</span><span class="s2">,</span><span class="si">{elmvector[88]}</span><span class="s2">,</span><span class="si">{elmvector[89]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[90]}</span><span class="s2">,</span><span class="si">{elmvector[91]}</span><span class="s2">,</span><span class="si">{elmvector[92]}</span><span class="s2">,</span><span class="si">{elmvector[93]}</span><span class="s2">,</span><span class="si">{elmvector[94]}</span><span class="s2">,</span><span class="si">{elmvector[95]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[96]}</span><span class="s2">,</span><span class="si">{elmvector[97]}</span><span class="s2">,</span><span class="si">{elmvector[98]}</span><span class="s2">,</span><span class="si">{elmvector[99]}</span><span class="s2">,</span><span class="si">{elmvector[100]}</span><span class="s2">,</span><span class="si">{elmvector[101]}</span><span class="s2">,</span>
<span class="s2">        </span><span class="si">{elmvector[102]}</span><span class="s2">,</span><span class="si">{elmvector[103]}</span><span class="s2">,</span><span class="si">{elmvector[104]}</span><span class="s2">,</span><span class="si">{elmvector[105]}</span><span class="s2"></span>
<span class="s2">    }};</span>

<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_elements(void) {{</span>
<span class="s2">    return elmformula;</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_g(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdt(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_s(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_v(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cv(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cp(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dcpdt(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_alpha(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_beta(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_K(T, P);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double T, double P) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_Kp(T, P);</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_h_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_fast_h_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(void);</span>
<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_mw(void);</span>
<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_elements(void);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double T, double P);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double T, double P);</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_pyx_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_fast_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">import numpy as np</span>
<span class="s2">cimport numpy as cnp # cimport gives us access to NumPy&#39;s C API</span>

<span class="s2"># here we just replicate the function signature from the header</span>
<span class="s2">cdef extern from &quot;</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calc.h&quot;:</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula();</span>
<span class="s2">    const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_mw();</span>
<span class="s2">    const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_elements();</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double t, double p)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double t, double p)</span>

<span class="s2"># here is the &quot;wrapper&quot; signature</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_mw():</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_mw()</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_elements():</span>
<span class="s2">    cdef const double *e = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_elements()</span>
<span class="s2">    np_array = np.zeros(106)</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        np_array[i] = e[i]</span>
<span class="s2">    return np_array</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double t, double p):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(&lt;double&gt; t, &lt;double&gt; p)</span>
<span class="s2">    return result</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_pyxbld_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_pyxbld_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    setuptools.extension.Extension</span>
<span class="sd">    self,</span>
<span class="sd">    name,</span>
<span class="sd">    sources,</span>
<span class="sd">    include_dirs=None,</span>
<span class="sd">    define_macros=None,</span>
<span class="sd">    undef_macros=None,</span>
<span class="sd">    library_dirs=None,</span>
<span class="sd">    libraries=None,</span>
<span class="sd">    runtime_library_dirs=None,</span>
<span class="sd">    extra_objects=None,</span>
<span class="sd">    extra_compile_args=None,</span>
<span class="sd">    extra_link_args=None,</span>
<span class="sd">    export_symbols=None,</span>
<span class="sd">    swig_opts=None,</span>
<span class="sd">    depends=None,</span>
<span class="sd">    language=None,</span>
<span class="sd">    optional=None,</span>
<span class="sd">    **kw</span>

<span class="sd">    -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4</span>
<span class="sd">    Specify which optimization level to use:</span>

<span class="sd">        -O0 Means “no optimization”: this level compiles the fastest and</span>
<span class="sd">        generates the most debuggable code.</span>
<span class="sd">        -O1 Somewhere between -O0 and -O2.</span>
<span class="sd">        -O2 Moderate level of optimization which enables most optimizations.</span>
<span class="sd">        -O3 Like -O2, except that it enables optimizations that take longer</span>
<span class="sd">        to perform or that may generate larger code (in an attempt to make</span>
<span class="sd">        the program run faster).</span>
<span class="sd">        -Ofast Enables all the optimizations from -O3 along with other</span>
<span class="sd">        agressive optimizations that may violate strict compliance with</span>
<span class="sd">        language standards.</span>
<span class="sd">        -Os Like -O2 with extra optimizations to reduce code size.</span>
<span class="sd">        -Oz Like -Os (and thus -O2), but reduces code size further.</span>
<span class="sd">        -Og Like -O1. In future versions, this option might disable</span>
<span class="sd">        different optimizations in order to improve debuggability.</span>
<span class="sd">        -O Equivalent to -O2.</span>
<span class="sd">        -O4 and higher</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">import numpy</span>

<span class="s2">#            module name specified by `</span><span class="si">%%</span><span class="s2">cython_pyximport` magic</span>
<span class="s2">#            |        just `modname + &quot;.pyx&quot;`</span>
<span class="s2">#            |        |</span>
<span class="s2">def make_ext(modname, pyxfilename):</span>
<span class="s2">    from setuptools.extension import Extension</span>
<span class="s2">    return Extension(modname,</span>
<span class="s2">                     sources=[pyxfilename, &#39;</span><span class="si">{file_to_compile}</span><span class="s2">&#39;],</span>
<span class="s2">                     include_dirs=[&#39;.&#39;, numpy.get_include()],</span>
<span class="s2">                     extra_compile_args=[&#39;-O3&#39;],</span>
<span class="s2">                     libraries=[&#39;gsl&#39;, &#39;swimdew&#39;],</span>
<span class="s2">                     library_dirs=[&#39;/usr/local/lib&#39;],</span>
<span class="s2">                     runtime_library_dirs=[&#39;/usr/local/lib&#39;])</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_redundant_calib_TV_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_redundant_calib_TV_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_g(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double dAdz = </span><span class="si">{module}</span><span class="s2">_dparam_a(T, V, index);</span>
<span class="s2">    return dAdz + P*V;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double dAdTdz = </span><span class="si">{module}</span><span class="s2">_dparam_dadt(T, V, index);</span>
<span class="s2">    return dAdTdz;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    return 0.0; /* V; */</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d2AdT2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adt2(T, V, index);</span>
<span class="s2">    double d2AdTdVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adtdv(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    /* return d2AdT2 - d2AdTdV*d2AdTdV/d2AdV2; */</span>
<span class="s2">    return d2AdT2dz - 2.0*d2AdTdV*d2AdTdVdz/d2AdV2 + d2AdTdV*d2AdTdV*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d2AdTdVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adtdv(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    /* return - d2AdTdV/d2AdV2; */</span>
<span class="s2">    return - d2AdTdVdz/d2AdV2 + d2AdTdV*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    /* return - 1.0/d2AdV2; */</span>
<span class="s2">    return d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdT2dV = </span><span class="si">{module}</span><span class="s2">_d3adt2dv(T, V);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d3AdT3dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adt3(T, V, index);</span>
<span class="s2">    double d3AdT2dVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adt2dv(T, V, index);</span>
<span class="s2">    double d3AdTdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adtdv2(T, V, index);</span>
<span class="s2">    double d3AdV3dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adv3(T, V, index);</span>
<span class="s2">    double d2AdTdVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adtdv(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    double dVdT = - d2AdTdV/d2AdV2;</span>
<span class="s2">    double dVdTdz = - d2AdTdVdz/d2AdV2 + d2AdTdV*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    double d2VdT2 = (-d3AdT2dV - 2.0*d3AdTdV2*dVdT - d3AdV3*dVdT*dVdT)/d2AdV2;</span>
<span class="s2">    double d2VdT2dz = (-d3AdT2dVdz - 2.0*d3AdTdV2dz*dVdT - 2.0*d3AdTdV2*dVdTdz</span>
<span class="s2">                        - d3AdV3dz*dVdT*dVdT - 2.0*d3AdV3*dVdT*dVdTdz)/d2AdV2</span>
<span class="s2">                    - (-d3AdT2dV - 2.0*d3AdTdV2*dVdT - d3AdV3*dVdT*dVdT)*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    /* return d3AdT3 + 2.0*d3AdT2dV*dVdT + d3AdTdV2*dVdT*dVdT + d2AdTdV*d2VdT2; */</span>
<span class="s2">    return d3AdT3dz + 2.0*d3AdT2dVdz*dVdT + 2.0*d3AdT2dV*dVdTdz + d3AdTdV2dz*dVdT*dVdT</span>
<span class="s2">            + 2.0*d3AdTdV2*dVdT*dVdTdz + d2AdTdVdz*d2VdT2 + d2AdTdV*d2VdT2dz;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdT2dV = </span><span class="si">{module}</span><span class="s2">_d3adt2dv(T, V);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d3AdT2dVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adt2dv(T, V, index);</span>
<span class="s2">    double d3AdTdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adtdv2(T, V, index);</span>
<span class="s2">    double d3AdV3dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adv3(T,V, index);</span>
<span class="s2">    double d2AdTdVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adtdv(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    double dVdT = -d2AdTdV/d2AdV2;</span>
<span class="s2">    double dVdTdz = - d2AdTdVdz/d2AdV2 + d2AdTdV*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    double dVdP = -1.0/d2AdV2;</span>
<span class="s2">    double dVdPdz = d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    double d2VdTdP = (-d3AdTdV2*dVdP - d3AdV3*dVdT*dVdP)/d2AdV2;</span>
<span class="s2">    double d2VdTdPdz = (-d3AdTdV2dz*dVdP -d3AdTdV2*dVdPdz</span>
<span class="s2">            - d3AdV3dz*dVdT*dVdP - d3AdV3*dVdTdz*dVdP - d3AdV3*dVdT*dVdPdz)/d2AdV2</span>
<span class="s2">            - (-d3AdTdV2*dVdP - d3AdV3*dVdT*dVdP)*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    /* return d3AdT2dV*dVdP + d3AdTdV2*dVdT*dVdP + d2AdTdV*d2VdTdP; */</span>
<span class="s2">    return d3AdT2dVdz*dVdP + d3AdT2dV*dVdPdz + d3AdTdV2dz*dVdT*dVdP + d3AdTdV2*dVdTdz*dVdP</span>
<span class="s2">        + d3AdTdV2*dVdT*dVdPdz + d2AdTdVdz*d2VdTdP + d2AdTdV*d2VdTdPdz;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d3AdTdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adtdv2(T, V, index);</span>
<span class="s2">    double d3AdV3dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adv3(T, V, index);</span>
<span class="s2">    double d2AdTdVdz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adtdv(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    double dVdT = -d2AdTdV/d2AdV2;</span>
<span class="s2">    double dVdTdz = - d2AdTdVdz/d2AdV2 + d2AdTdV*d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    /* return (d3AdTdV2 + d3AdV3*dVdT)/d2AdV2/d2AdV2; */</span>
<span class="s2">    return (d3AdTdV2dz + d3AdV3dz*dVdT + d3AdV3*dVdTdz)/d2AdV2/d2AdV2</span>
<span class="s2">        - 2.0*(d3AdTdV2 + d3AdV3*dVdT)*d2AdV2dz/d2AdV2/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double T, double P, int index) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double d3AdV3dz = </span><span class="si">{module}</span><span class="s2">_dparam_d3adv3(T, V, index);</span>
<span class="s2">    double d2AdV2dz = </span><span class="si">{module}</span><span class="s2">_dparam_d2adv2(T, V, index);</span>
<span class="s2">    double dVdP = -1.0/d2AdV2;</span>
<span class="s2">    double dVdPdz = d2AdV2dz/d2AdV2/d2AdV2;</span>
<span class="s2">    /* return d3AdV3*dVdP/d2AdV2/d2AdV2; */</span>
<span class="s2">    return d3AdV3dz*dVdP/d2AdV2/d2AdV2 + d3AdV3*dVdPdz/d2AdV2/d2AdV2</span>
<span class="s2">        - 2.0*d3AdV3*dVdP*d2AdV2dz/d2AdV2/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_redundant_function_template_c</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;TP&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_redundant_function_template()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_type: string</span>
<span class="sd">        Potential type, either Gibbs free energy (&#39;TP&#39;) or Helmholtz free</span>
<span class="sd">        energy (&#39;TV&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;TP&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_s(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdt(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_v(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cv(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    double dvdt = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P);</span>
<span class="s2">    double dvdp = </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">    result += T*dvdt*dvdt/dvdp;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cp(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P) - </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_alpha(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_beta(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_K(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdp(T, P)/</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_Kp(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    result *= </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P);</span>
<span class="s2">    result /= pow(</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P), 2.0);</span>
<span class="s2">    return result - 1.0;</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;TV&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double V = </span><span class="si">{v_initial_guess}</span><span class="s2">;</span>
<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_solve_V(double T, double P) {{</span>
<span class="s2">    static double Told = 0.0;</span>
<span class="s2">    static double Pold = 0.0;</span>
<span class="s2">    if ((T != Told) &amp;&amp; (P != Pold)) {{</span>
<span class="s2">        Told = T;</span>
<span class="s2">        Pold = P;</span>
<span class="s2">        double f = 0.0;</span>
<span class="s2">        int iter = 0;</span>
<span class="s2">        do {{</span>
<span class="s2">            f = -</span><span class="si">{module}</span><span class="s2">_dadv(T, V) - P;</span>
<span class="s2">            double df = -</span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">            if (df == 0.0) break;</span>
<span class="s2">            V -= f/df;</span>
<span class="s2">            if (V &lt;= 0.0) V = 0.001;</span>
<span class="s2">            else if (V &gt;= 4.0*</span><span class="si">{v_initial_guess}</span><span class="s2">) V = 4.0*</span><span class="si">{v_initial_guess}</span><span class="s2">;</span>
<span class="s2">            iter++;</span>
<span class="s2">        }} while ((fabs(f) &gt; 0.001) &amp;&amp; (iter &lt; 200));</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_g(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double A = </span><span class="si">{module}</span><span class="s2">_a(T, V);</span>
<span class="s2">    return A + P*V;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double dAdT = </span><span class="si">{module}</span><span class="s2">_dadt(T, V);</span>
<span class="s2">    return dAdT;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    return V;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdT2 = </span><span class="si">{module}</span><span class="s2">_d2adt2(T, V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    return d2AdT2 - d2AdTdV*d2AdTdV/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    return - d2AdTdV/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    return - 1.0/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdT3 = </span><span class="si">{module}</span><span class="s2">_d3adt3(T, V);</span>
<span class="s2">    double d3AdT2dV = </span><span class="si">{module}</span><span class="s2">_d3adt2dv(T, V);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double dVdT = -d2AdTdV/d2AdV2;</span>
<span class="s2">    double d2VdT2 = (-d3AdT2dV - 2.0*d3AdTdV2*dVdT - d3AdV3*dVdT*dVdT)/d2AdV2;</span>
<span class="s2">    return d3AdT3 + 2.0*d3AdT2dV*dVdT + d3AdTdV2*dVdT*dVdT + d2AdTdV*d2VdT2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdT2dV = </span><span class="si">{module}</span><span class="s2">_d3adt2dv(T, V);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double dVdT = -d2AdTdV/d2AdV2;</span>
<span class="s2">    double dVdP = -1.0/d2AdV2;</span>
<span class="s2">    double d2VdTdP = (-d3AdTdV2*dVdP - d3AdV3*dVdT*dVdP)/d2AdV2;</span>
<span class="s2">    return d3AdT2dV*dVdP + d3AdTdV2*dVdT*dVdP + d2AdTdV*d2VdTdP;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdTdV2 = </span><span class="si">{module}</span><span class="s2">_d3adtdv2(T, V);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdTdV = </span><span class="si">{module}</span><span class="s2">_d2adtdv(T, V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double dVdT = -d2AdTdV/d2AdV2;</span>
<span class="s2">    return (d3AdTdV2 + d3AdV3*dVdT)/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_solve_V(T, P);</span>
<span class="s2">    double d3AdV3 = </span><span class="si">{module}</span><span class="s2">_d3adv3(T,V);</span>
<span class="s2">    double d2AdV2 = </span><span class="si">{module}</span><span class="s2">_d2adv2(T, V);</span>
<span class="s2">    double dVdP = -1.0/d2AdV2;</span>
<span class="s2">    return d3AdV3*dVdP/d2AdV2/d2AdV2;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_s(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdt(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_v(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cv(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    double dvdt = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P);</span>
<span class="s2">    double dvdp = </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">    result += T*dvdt*dvdt/dvdp;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cp(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P) - </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_alpha(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_beta(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_K(double T, double P) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdp(T, P)/</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_Kp(double T, double P) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P);</span>
<span class="s2">    result *= </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P);</span>
<span class="s2">    result /= pow(</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P), 2.0);</span>
<span class="s2">    return result - 1.0;</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Unsupported model_type: &quot;</span><span class="p">,</span> <span class="n">model_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="c1">###############################</span>
<span class="c1"># Simple Solution C templates #</span>
<span class="c1">###############################</span>

<span class="k">def</span> <span class="nf">_create_soln_calc_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calc_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_</span><span class="si">{func}</span><span class="s2">(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    double result;</span>
<span class="s2">    </span><span class="si">{g_code}</span><span class="s2"></span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>
<span class="s2">    </span><span class="se">\</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_code_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calib_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static char *identifier = &quot;</span><span class="si">{git_identifier}</span><span class="s2">&quot;;</span>
<span class="si">{code_block_two}</span><span class="s2"></span>

<span class="s2">#include &quot;</span><span class="si">{module}</span><span class="s2">_calc.h&quot;</span>
<span class="s2">#include &quot;</span><span class="si">{module}</span><span class="s2">_calib.h&quot;</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier(void) {{</span>
<span class="s2">    return identifier;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{phase}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{code_block_five}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(double *e) {{</span>
<span class="si">{code_block_six}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_test_moles(double *n) {{</span>
<span class="si">{code_block_seven}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(int index) {{</span>
<span class="s2">    return (*endmember[index].name)();</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(int index) {{</span>
<span class="s2">    return (*endmember[index].formula)();</span>
<span class="s2">}}</span>

<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(int index) {{</span>
<span class="s2">    return (*endmember[index].mw)();</span>
<span class="s2">}}</span>

<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(int index) {{</span>
<span class="s2">    return (*endmember[index].elements)();</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mu0(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].mu0)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dT(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].dmu0dT)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].dmu0dP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dT2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dT2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dTdP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dTdP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dP2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dP2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT3(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dT3)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT2dP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dT2dP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dTdP2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dTdP2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dP3(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dP3)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_g(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_dgdn(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdn2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdt(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdndt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn2dt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn3dt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdndp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn3dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_s(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_v(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cv(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dcpdt(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_alpha(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_beta(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_K(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_Kp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_number();</span>
<span class="s2">}}</span>

<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_names();</span>
<span class="s2">}}</span>

<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units(void) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_units();</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_get_param_values(values);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_set_param_values(values);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_get_param_value(index);</span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_set_param_value(index, value);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_g(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_dgdt(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_dgdp(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(T, P, n, index);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index, double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_dparam_dgdn(T, P, n, index, result);</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_extra_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calib_extra_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static int </span><span class="si">{module}</span><span class="s2">_get_param_number(void) {{</span>
<span class="s2">    return </span><span class="si">{number_params}</span><span class="s2">;</span>
<span class="s2">}}</span>

<span class="s2">static const char *paramNames[</span><span class="si">{number_params}</span><span class="s2">] = </span><span class="si">{names_params}</span><span class="s2">;</span>
<span class="s2">static const char *paramUnits[</span><span class="si">{number_params}</span><span class="s2">] = </span><span class="si">{units_params}</span><span class="s2">;</span>

<span class="s2">static const char **</span><span class="si">{module}</span><span class="s2">_get_param_names(void) {{</span>
<span class="s2">    return paramNames;</span>
<span class="s2">}}</span>

<span class="s2">static const char **</span><span class="si">{module}</span><span class="s2">_get_param_units(void) {{</span>
<span class="s2">    return paramUnits;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_get_param_values(double **values) {{</span>
<span class="si">{code_block_one}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">static int </span><span class="si">{module}</span><span class="s2">_set_param_values(double *values) {{</span>
<span class="si">{code_block_two}</span><span class="s2"></span>
<span class="s2">    return 1;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_get_param_value(int index) {{</span>
<span class="s2">    double result = 0.0;</span>
<span class="s2">    switch (index) {{</span>
<span class="si">{code_block_three}</span><span class="s2"></span>
<span class="s2">    default:</span>
<span class="s2">        break;</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static int </span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value) {{</span>
<span class="s2">    int result = 1;</span>
<span class="s2">    switch (index) {{</span>
<span class="si">{code_block_four}</span><span class="s2"></span>
<span class="s2">    default:</span>
<span class="s2">        result = 0;</span>
<span class="s2">        break;</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_include_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_fcalib_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name(void);</span>
<span class="s2">char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(double *e);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_test_moles(double *n);</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(int index);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(int index);</span>
<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(int index);</span>
<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mu0(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dT(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dT2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dTdP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dP2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT3(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT2dP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dTdP2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dP3(int index, double t, double p);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>


<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number(void);</span>
<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names(void);</span>
<span class="s2">const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units(void);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index, double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_pyx_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calib_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2"># Cython numpy wrapper code for arrays is taken from:</span>
<span class="s2"># http://gael-varoquaux.info/programming/cython-example-of-exposing-c-computed-arrays-in-python-without-data-copies.html</span>
<span class="s2"># Author: Gael Varoquaux, BSD license</span>

<span class="s2"># Declare the prototype of the C functions</span>
<span class="s2">cdef extern from &quot;</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib.h&quot;:</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name();</span>
<span class="s2">    char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(double *e);</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_test_moles(double *n);</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(int index);</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(int index);</span>
<span class="s2">    const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(int index);</span>
<span class="s2">    const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mu0(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dT(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dT2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dTdP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dP2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT3(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT2dP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dTdP2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dP3(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names()</span>
<span class="s2">    const char **</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units()</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(double **values)</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(double *values)</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index)</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value)</span>

<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index);</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdn(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">], int index, double result[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">from libc.stdlib cimport malloc, free</span>
<span class="s2">from cpython cimport PyObject, Py_INCREF</span>
<span class="s2">import ctypes</span>

<span class="s2"># Import the Python-level symbols of numpy</span>
<span class="s2">import numpy as np</span>

<span class="s2"># Import the C-level symbols of numpy</span>
<span class="s2">cimport numpy as np</span>

<span class="s2"># Numpy must be initialized. When using numpy from C or Cython you must</span>
<span class="s2"># _always_ do that, or you will have segfaults</span>
<span class="s2">np.import_array()</span>

<span class="s2"># here is the &quot;wrapper&quot; signature</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_identifier()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_name()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_formula(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    result = &lt;bytes&gt; r</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(np_array):</span>
<span class="s2">    cdef double *e = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        e[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(&lt;double *&gt; e)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (e)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_tot_moles(np_array):</span>
<span class="s2">    cdef double *e = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        e[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(&lt;double *&gt; e)</span>
<span class="s2">    result = 0.0</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result += r[i]</span>
<span class="s2">    free (e)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_tot_grams(np_array):</span>
<span class="s2">    cdef double *e = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        e[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_elm_to_moles(&lt;double *&gt; e)</span>
<span class="s2">    result = 0.0</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        mw = </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(i)</span>
<span class="s2">        result += r[i]*mw</span>
<span class="s2">    free (e)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_moles_to_tot_moles(np_array):</span>
<span class="s2">    result = 0.0</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result += np_array[i]</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_moles_to_mole_frac(np_array):</span>
<span class="s2">    result = np.zeros(</span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    sum = np.sum(np_array)</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result[i] += np_array[i]/sum</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_conv_moles_to_elm(np_array):</span>
<span class="s2">    result = np.zeros(106)</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        end = </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(i)</span>
<span class="s2">        for j in range(0,106):</span>
<span class="s2">            result[j] += np_array[i]*end[j]</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_test_moles(np_array):</span>
<span class="s2">    cdef double *n = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        n[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_test_moles(&lt;double *&gt; n)</span>
<span class="s2">    free (n)</span>
<span class="s2">    return False if result == 0 else True</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_number():</span>
<span class="s2">    return </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(index);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(index);</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_species_number():</span>
<span class="s2">    return </span><span class="si">{number_species}</span><span class="s2"></span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_species_name(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_name(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_species_formula(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_formula(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_species_mw(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mw(index);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_species_elements(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_elements(index);</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mu0(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_mu0(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dT(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dT(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_dmu0dP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dT2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dT2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dTdP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dTdP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dP2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d2mu0dP2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT3(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT3(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT2dP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dT2dP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dTdP2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dTdP2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dP3(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_endmember_d3mu0dP3(index, &lt;double&gt; t, &lt;double&gt; p);</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_g(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_s(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_v(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cv(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_cp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dcpdt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_alpha(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_beta(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_K(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_Kp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdn(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_dgdn(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdndp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdndp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndp4(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdndp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdn2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d2gdn2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn2dp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn2dp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d3gdn3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d4gdn3dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d5gdn3dp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calib_d6gdn3dp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>


<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number():</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names():</span>
<span class="s2">    cdef const char **names = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_names()</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,n):</span>
<span class="s2">        entry = &lt;bytes&gt; names[i]</span>
<span class="s2">        result.append(entry.decode(&#39;UTF-8&#39;))</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units():</span>
<span class="s2">    cdef const char **units = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_units()</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,n):</span>
<span class="s2">        entry = &lt;bytes&gt; units[i]</span>
<span class="s2">        result.append(entry.decode(&#39;UTF-8&#39;))</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values():</span>
<span class="s2">    n = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_number()</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(n*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_values(&amp;m)</span>
<span class="s2">    np_array = np.zeros(n)</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        np_array[i] = m[i]</span>
<span class="s2">    free(m)</span>
<span class="s2">    return np_array</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(np_array):</span>
<span class="s2">    n = len(np_array)</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(n*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_values(m);</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(int index):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_get_param_value(&lt;int&gt; index)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(int index, double value):</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_set_param_value(&lt;int&gt; index, &lt;double&gt; value)</span>
<span class="s2">    return result</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_g(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d2gdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_d3gdp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index)</span>
<span class="s2">    free(m)</span>
<span class="s2">    return result</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdn(double t, double p, np_array, int index):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dparam_dgdn(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;int&gt; index, &lt;double *&gt; r)</span>
<span class="s2">    r_np_array = np.zeros(len(np_array))</span>
<span class="s2">    for i in range(r_np_array.size):</span>
<span class="s2">        r_np_array[i] = r[i]</span>
<span class="s2">    free(m)</span>
<span class="s2">    free(r)</span>
<span class="s2">    return r_np_array</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calib_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_</span><span class="si">{func}</span><span class="s2">(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    double result = 0.0;</span>
<span class="s2">    switch (index) {{</span>
<span class="si">{switch_code}</span><span class="s2"></span>
<span class="s2">    default:</span>
<span class="s2">        break;</span>
<span class="s2">    }}</span>
<span class="s2">        return result;</span>
<span class="s2">}}</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_deriv_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_deriv_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_</span><span class="si">{func}</span><span class="s2">(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="si">{derivative_code}</span><span class="s2"></span>
<span class="s2">}}</span>
<span class="s2">    </span><span class="se">\</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_code_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_fast_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static const char *identifier = &quot;</span><span class="si">{git_identifier}</span><span class="s2">&quot;;</span>
<span class="si">{code_block_one}</span><span class="s2"></span>

<span class="s2">#include &quot;</span><span class="si">{module}</span><span class="s2">_calc.h&quot;</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier(void) {{</span>
<span class="s2">    return identifier;</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name(void) {{</span>
<span class="s2">    return &quot;</span><span class="si">{phase}</span><span class="s2">&quot;;</span>
<span class="s2">}}</span>

<span class="s2">char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{code_block_five}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_conv_elm_to_moles(double *e) {{</span>
<span class="si">{code_block_six}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_test_moles(double *n) {{</span>
<span class="si">{code_block_seven}</span><span class="s2"></span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(int index) {{</span>
<span class="s2">    return (*endmember[index].name)();</span>
<span class="s2">}}</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(int index) {{</span>
<span class="s2">    return (*endmember[index].formula)();</span>
<span class="s2">}}</span>

<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(int index) {{</span>
<span class="s2">    return (*endmember[index].mw)();</span>
<span class="s2">}}</span>

<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(int index) {{</span>
<span class="s2">    return (*endmember[index].elements)();</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mu0(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].mu0)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dT(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].dmu0dT)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].dmu0dP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dT2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dT2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dTdP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dTdP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dP2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d2mu0dP2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT3(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dT3)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT2dP(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dT2dP)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dTdP2(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dTdP2)(t, p);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dP3(int index, double t, double p) {{</span>
<span class="s2">    return (*endmember[index].d3mu0dP3)(t, p);</span>
<span class="s2">}}</span>


<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_g(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_dgdn(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdn2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdt(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdndt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn2dt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn3dt(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d2gdndp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdn2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn3dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d3gdndp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d4gdndp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(T, P, n, result);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_s(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_v(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cv(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_cp(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_dcpdt(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_alpha(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_beta(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_K(T, P, n);</span>
<span class="s2">}}</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    return </span><span class="si">{module}</span><span class="s2">_Kp(T, P, n);</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_include_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_fast_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier(void);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name(void);</span>
<span class="s2">char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_conv_elm_to_moles(double *e);</span>
<span class="s2">int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_test_moles(double *n);</span>

<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(int index);</span>
<span class="s2">const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(int index);</span>
<span class="s2">const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(int index);</span>
<span class="s2">const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(int index);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mu0(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dT(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dT2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dTdP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dP2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT3(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT2dP(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dTdP2(int index, double t, double p);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dP3(int index, double t, double p);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_pyx_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_fast_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2"># Cython numpy wrapper code for arrays is taken from:</span>
<span class="s2"># http://gael-varoquaux.info/programming/cython-example-of-exposing-c-computed-arrays-in-python-without-data-copies.html</span>
<span class="s2"># Author: Gael Varoquaux, BSD license</span>

<span class="s2"># Declare the prototype of the C functions</span>
<span class="s2">cdef extern from &quot;</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_calc.h&quot;:</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier();</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name();</span>
<span class="s2">    char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_conv_elm_to_moles(double *e);</span>
<span class="s2">    int </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_test_moles(double *n);</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(int index);</span>
<span class="s2">    const char *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(int index);</span>
<span class="s2">    const double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(int index);</span>
<span class="s2">    const double *</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(int index);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mu0(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dT(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dT2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dTdP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dP2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT3(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT2dP(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dTdP2(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dP3(int index, double t, double p);</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>
<span class="s2">    double </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double t, double p, double n[</span><span class="si">{number_components}</span><span class="s2">])</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>
<span class="s2">    void </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], double result[</span><span class="si">{number_components}</span><span class="s2">]);</span>

<span class="s2">from libc.stdlib cimport malloc, free</span>
<span class="s2">from cpython cimport PyObject, Py_INCREF</span>
<span class="s2">import ctypes</span>

<span class="s2"># Import the Python-level symbols of numpy</span>
<span class="s2">import numpy as np</span>

<span class="s2"># Import the C-level symbols of numpy</span>
<span class="s2">cimport numpy as np</span>

<span class="s2"># Numpy must be initialized. When using numpy from C or Cython you must</span>
<span class="s2"># _always_ do that, or you will have segfaults</span>
<span class="s2">np.import_array()</span>

<span class="s2"># here is the &quot;wrapper&quot; signature</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_identifier()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name():</span>
<span class="s2">    result = &lt;bytes&gt; </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_name()</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_formula(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    result = &lt;bytes&gt; r</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_conv_elm_to_moles(np_array):</span>
<span class="s2">    cdef double *e = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        e[i] = np_array[i]</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_conv_elm_to_moles(&lt;double *&gt; e)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free(r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_test_moles(np_array):</span>
<span class="s2">    cdef double *n = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        n[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_test_moles(&lt;double *&gt; n)</span>
<span class="s2">    return False if result == 0 else True</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_number():</span>
<span class="s2">    return </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(index);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(index);</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_species_number():</span>
<span class="s2">    return </span><span class="si">{number_species}</span><span class="s2"></span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_species_name(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_name(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_species_formula(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_formula(index);</span>
<span class="s2">    return result.decode(&#39;UTF-8&#39;)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_species_mw(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mw(index);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_species_elements(int index):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_species}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    r = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_elements(index);</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(0,106):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mu0(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_mu0(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dT(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dT(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_dmu0dP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dT2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dT2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dTdP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dTdP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dP2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d2mu0dP2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT3(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT3(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT2dP(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dT2dP(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dTdP2(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dTdP2(index, &lt;double&gt; t, &lt;double&gt; p);</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dP3(int index, double t, double p):</span>
<span class="s2">    assert index in range(0,</span><span class="si">{number_components}</span><span class="s2">), &quot;index out of range&quot;</span>
<span class="s2">    return </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_endmember_d3mu0dP3(index, &lt;double&gt; t, &lt;double&gt; p);</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_g(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_s(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_v(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cv(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_cp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dcpdt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_alpha(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_beta(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_K(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    result = </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_Kp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m)</span>
<span class="s2">    free (m)</span>
<span class="s2">    return result</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdn(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_dgdn(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdndp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdndp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndp4(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(</span><span class="si">{number_components}</span><span class="s2">*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdndp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(</span><span class="si">{number_components}</span><span class="s2">):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdn2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d2gdn2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    ndim = int(</span><span class="si">{number_components}</span><span class="s2">*(</span><span class="si">{number_components}</span><span class="s2">-1)/2 + </span><span class="si">{number_components}</span><span class="s2">)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>

<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d3gdn3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dt(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dt(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d4gdn3dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="s2">def </span><span class="si">{prefix}</span><span class="s2">_</span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(double t, double p, np_array):</span>
<span class="s2">    cdef double *m = &lt;double *&gt;malloc(len(np_array)*sizeof(double))</span>
<span class="s2">    for i in range(np_array.size):</span>
<span class="s2">        m[i] = np_array[i]</span>
<span class="s2">    nc = </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">    ndim = int(nc*(nc+1)*(nc+2)/6)</span>
<span class="s2">    cdef double *r = &lt;double *&gt;malloc(ndim*sizeof(double))</span>
<span class="s2">    </span><span class="si">{phase}</span><span class="s2">_</span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(&lt;double&gt; t, &lt;double&gt; p, &lt;double *&gt; m, &lt;double *&gt; r)</span>
<span class="s2">    result = []</span>
<span class="s2">    for i in range(ndim):</span>
<span class="s2">        result.append(r[i])</span>
<span class="s2">    free (m)</span>
<span class="s2">    free (r)</span>
<span class="s2">    return np.array(result)</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_pyxbld_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_pyxbld_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    setuptools.extension.Extension</span>
<span class="sd">    self,</span>
<span class="sd">    name,</span>
<span class="sd">    sources,</span>
<span class="sd">    include_dirs=None,</span>
<span class="sd">    define_macros=None,</span>
<span class="sd">    undef_macros=None,</span>
<span class="sd">    library_dirs=None,</span>
<span class="sd">    libraries=None,</span>
<span class="sd">    runtime_library_dirs=None,</span>
<span class="sd">    extra_objects=None,</span>
<span class="sd">    extra_compile_args=None,</span>
<span class="sd">    extra_link_args=None,</span>
<span class="sd">    export_symbols=None,</span>
<span class="sd">    swig_opts=None,</span>
<span class="sd">    depends=None,</span>
<span class="sd">    language=None,</span>
<span class="sd">    optional=None,</span>
<span class="sd">    **kw</span>

<span class="sd">    -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4</span>
<span class="sd">    Specify which optimization level to use:</span>

<span class="sd">        -O0 Means “no optimization”: this level compiles the fastest and</span>
<span class="sd">        generates the most debuggable code.</span>
<span class="sd">        -O1 Somewhere between -O0 and -O2.</span>
<span class="sd">        -O2 Moderate level of optimization which enables most optimizations.</span>
<span class="sd">        -O3 Like -O2, except that it enables optimizations that take longer</span>
<span class="sd">        to perform or that may generate larger code (in an attempt to make</span>
<span class="sd">        the program run faster).</span>
<span class="sd">        -Ofast Enables all the optimizations from -O3 along with other</span>
<span class="sd">        agressive optimizations that may violate strict compliance with</span>
<span class="sd">        language standards.</span>
<span class="sd">        -Os Like -O2 with extra optimizations to reduce code size.</span>
<span class="sd">        -Oz Like -Os (and thus -O2), but reduces code size further.</span>
<span class="sd">        -Og Like -O1. In future versions, this option might disable</span>
<span class="sd">        different optimizations in order to improve debuggability.</span>
<span class="sd">        -O Equivalent to -O2.</span>
<span class="sd">        -O4 and higher</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">import numpy</span>

<span class="s2">#            module name specified by `</span><span class="si">%%</span><span class="s2">cython_pyximport` magic</span>
<span class="s2">#            |        just `modname + &quot;.pyx&quot;`</span>
<span class="s2">#            |        |</span>
<span class="s2">def make_ext(modname, pyxfilename):</span>
<span class="s2">    from setuptools.extension import Extension</span>
<span class="s2">    return Extension(modname,</span>
<span class="s2">                     sources=[pyxfilename, </span><span class="si">{files_to_compile}</span><span class="s2">],</span>
<span class="s2">                     include_dirs=[&#39;.&#39;, numpy.get_include()], extra_compile_args=[&#39;-O3&#39;])</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_redun_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_deriv_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_s(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdt(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_v(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cv(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P, n);</span>
<span class="s2">    double dvdt = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P, n);</span>
<span class="s2">    double dvdp = </span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n);</span>
<span class="s2">    result += T*dvdt*dvdt/dvdp;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_cp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dcpdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -T*</span><span class="si">{module}</span><span class="s2">_d3gdt3(T, P, n) - </span><span class="si">{module}</span><span class="s2">_d2gdt2(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_alpha(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_d2gdtdp(T, P, n)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_beta(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n)/</span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_K(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = -</span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n)/</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n);</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_Kp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    double result = </span><span class="si">{module}</span><span class="s2">_dgdp(T, P, n);</span>
<span class="s2">    result *= </span><span class="si">{module}</span><span class="s2">_d3gdp3(T, P, n);</span>
<span class="s2">    result /= pow(</span><span class="si">{module}</span><span class="s2">_d2gdp2(T, P, n), 2.0);</span>
<span class="s2">    return result - 1.0;</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_std_state_include_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_std_state_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Structure looks like:</span>
<span class="sd">    typedef struct _endmembers {</span>
<span class="sd">        const char *(*name) (void);</span>
<span class="sd">        const char *(*formula) (void);</span>
<span class="sd">        const double (*mw) (void);</span>
<span class="sd">        double (*mu0) (double t, double p);</span>
<span class="sd">        double (*dmu0dT) (double t, double p);</span>
<span class="sd">        double (*dmu0dP) (double t, double p);</span>
<span class="sd">        double (*d2mu0dT2) (double t, double p);</span>
<span class="sd">        double (*d2mu0dTdP) (double t, double p);</span>
<span class="sd">        double (*d2mu0dP2) (double t, double p);</span>
<span class="sd">        double (*d3mu0dT3) (double t, double p);</span>
<span class="sd">        double (*d3mu0dT2dP) (double t, double p);</span>
<span class="sd">        double (*d3mu0dTdP2) (double t, double p);</span>
<span class="sd">        double (*d3mu0dP3) (double t, double p);</span>
<span class="sd">    } Endmembers;</span>
<span class="sd">    static Endmembers endmember[] = {</span>
<span class="sd">        {</span>
<span class="sd">            Albite_berman_name,</span>
<span class="sd">            Albite_berman_formula,</span>
<span class="sd">            Albite_berman_mw,</span>
<span class="sd">            Albite_berman_g,</span>
<span class="sd">            Albite_berman_dgdt,</span>
<span class="sd">            Albite_berman_dgdp,</span>
<span class="sd">            Albite_berman_d2gdt2,</span>
<span class="sd">            Albite_berman_d2gdtdp,</span>
<span class="sd">            Albite_berman_d2gdp2,</span>
<span class="sd">            Albite_berman_d3gdt3,</span>
<span class="sd">            Albite_berman_d3gdt2dp,</span>
<span class="sd">            Albite_berman_d3gdtdp2,</span>
<span class="sd">            Albite_berman_d3gdp3</span>
<span class="sd">        },</span>
<span class="sd">        {</span>
<span class="sd">            Anorthite_berman_name,</span>
<span class="sd">            Anorthite_berman_formula,</span>
<span class="sd">            Anorthite_berman_mw,</span>
<span class="sd">            Anorthite_berman_g,</span>
<span class="sd">            Anorthite_berman_dgdt,</span>
<span class="sd">            Anorthite_berman_dgdp,</span>
<span class="sd">            Anorthite_berman_d2gdt2,</span>
<span class="sd">            Anorthite_berman_d2gdtdp,</span>
<span class="sd">            Anorthite_berman_d2gdp2,</span>
<span class="sd">            Anorthite_berman_d3gdt3,</span>
<span class="sd">            Anorthite_berman_d3gdt2dp,</span>
<span class="sd">            Anorthite_berman_d3gdtdp2,</span>
<span class="sd">            Anorthite_berman_d3gdp3</span>
<span class="sd">        },</span>
<span class="sd">        {</span>
<span class="sd">            Sanidine_berman_name,</span>
<span class="sd">            Sanidine_berman_formula,</span>
<span class="sd">            Sanidine_berman_mw,</span>
<span class="sd">            Sanidine_berman_g,</span>
<span class="sd">            Sanidine_berman_dgdt,</span>
<span class="sd">            Sanidine_berman_dgdp,</span>
<span class="sd">            Sanidine_berman_d2gdt2,</span>
<span class="sd">            Sanidine_berman_d2gdtdp,</span>
<span class="sd">            Sanidine_berman_d2gdp2,</span>
<span class="sd">            Sanidine_berman_d3gdt3,</span>
<span class="sd">            Sanidine_berman_d3gdt2dp,</span>
<span class="sd">            Sanidine_berman_d3gdtdp2,</span>
<span class="sd">            Sanidine_berman_d3gdp3</span>
<span class="sd">        }</span>
<span class="sd">    };</span>
<span class="sd">    static int nc = (sizeof endmember / sizeof(_endmembers));</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">#include &lt;stdlib.h&gt;</span>
<span class="s2">#include &lt;stdio.h&gt;</span>

<span class="si">{code_block_four}</span><span class="s2"></span>

<span class="s2">typedef struct _endmembers {{</span>
<span class="s2">  const char *(*name) (void);</span>
<span class="s2">  const char *(*formula) (void);</span>
<span class="s2">  const double (*mw) (void);</span>
<span class="s2">  const double *(*elements) (void);</span>
<span class="s2">  double (*mu0) (double t, double p);</span>
<span class="s2">  double (*dmu0dT) (double t, double p);</span>
<span class="s2">  double (*dmu0dP) (double t, double p);</span>
<span class="s2">  double (*d2mu0dT2) (double t, double p);</span>
<span class="s2">  double (*d2mu0dTdP) (double t, double p);</span>
<span class="s2">  double (*d2mu0dP2) (double t, double p);</span>
<span class="s2">  double (*d3mu0dT3) (double t, double p);</span>
<span class="s2">  double (*d3mu0dT2dP) (double t, double p);</span>
<span class="s2">  double (*d3mu0dTdP2) (double t, double p);</span>
<span class="s2">  double (*d3mu0dP3) (double t, double p);</span>
<span class="s2">}} Endmembers;</span>

<span class="s2">static Endmembers endmember[] = {{</span>
<span class="si">{code_block_three}</span><span class="s2"></span>
<span class="s2">}};</span>
<span class="s2">static int nc = (sizeof endmember / sizeof(struct _endmembers));</span>

<span class="s2">static const double R=8.3143;</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_ordering_gaussj_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_ordering_gaussj_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">#define SWAP(a,b) {{temp=(a);(a)=(b);(b)=temp;}}</span>

<span class="s2">static void gaussj(double a[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    int indxc[</span><span class="si">{NS}</span><span class="s2">], indxr[</span><span class="si">{NS}</span><span class="s2">], ipiv[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, icol = -1, irow = -1, j, k, l,ll;</span>
<span class="s2">    double big, dum, pivinv, temp;</span>

<span class="s2">    for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) ipiv[j]=0;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        big=0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++)</span>
<span class="s2">            if (ipiv[j] != 1)</span>
<span class="s2">                for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                    if (ipiv[k] == 0) {{</span>
<span class="s2">                        if (fabs(a[j][k]) &gt;= big) {{</span>
<span class="s2">                            big = fabs(a[j][k]);</span>
<span class="s2">                            irow = j;</span>
<span class="s2">                            icol = k;</span>
<span class="s2">                        }}</span>
<span class="s2">                    }} else if (ipiv[k] &gt; 1) return;</span>
<span class="s2">                }}</span>
<span class="s2">        ++(ipiv[icol]);</span>
<span class="s2">        if (irow != icol) {{</span>
<span class="s2">            for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) SWAP(a[irow][l],a[icol][l])</span>
<span class="s2">                }}</span>
<span class="s2">        indxr[i] = irow;</span>
<span class="s2">        indxc[i] = icol;</span>
<span class="s2">        if (a[icol][icol] == 0.0) return;</span>
<span class="s2">        pivinv = 1.0/a[icol][icol];</span>
<span class="s2">        a[icol][icol] = 1.0;</span>
<span class="s2">        for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) a[icol][l] *= pivinv;</span>
<span class="s2">        for (ll=0; ll&lt;</span><span class="si">{NS}</span><span class="s2">; ll++)</span>
<span class="s2">            if (ll != icol) {{</span>
<span class="s2">                dum = a[ll][icol];</span>
<span class="s2">                a[ll][icol] = 0.0;</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) a[ll][l] -= a[icol][l]*dum;</span>
<span class="s2">            }}</span>
<span class="s2">    }}</span>
<span class="s2">    for (l=(</span><span class="si">{NS}</span><span class="s2">-1); l&gt;=0; l--) {{</span>
<span class="s2">        if (indxr[l] != indxc[l])</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++)</span>
<span class="s2">                SWAP(a[k][indxr[l]],a[k][indxc[l]]);</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_ordering_code_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_ordering_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static void order_s(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dgds[</span><span class="si">{NS}</span><span class="s2">], sOld[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, iter = 0;</span>
<span class="si">{ORDER_CODE_BLOCK_ZERO}</span><span class="s2"></span>
<span class="s2">    do {{</span>
<span class="s2">        double deltaS[</span><span class="si">{NS}</span><span class="s2">], steplength;</span>
<span class="si">{ORDER_CODE_BLOCK_TWO}</span><span class="s2"></span>
<span class="s2">        for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) sOld[i] = s[i];</span>

<span class="si">{ORDER_CODE_BLOCK_THREE}</span><span class="s2"></span>
<span class="s2">        for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">            for(j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) s[i] += - invd2gds2[i][j]*dgds[j];</span>
<span class="s2">            deltaS[i] = s[i] - sOld[i];</span>
<span class="s2">        }}</span>

<span class="s2">        steplength = 2.0;</span>

<span class="si">{ORDER_CODE_BLOCK_FOUR}</span><span class="s2"></span>
<span class="s2">        if (steplength &lt; 1.0) for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++)</span>
<span class="s2">            s[i] = sOld[i] + steplength*deltaS[i];</span>
<span class="s2">        iter++;</span>
<span class="s2">    }} while ((</span><span class="si">{ORDER_CODE_BLOCK_ONE}</span><span class="s2">) &amp;&amp; (iter &lt; </span><span class="si">{MAX_ITER}</span><span class="s2">));</span>
<span class="s2">}}</span>

<span class="s2">static void order_dsdn(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="si">{ORDER_CODE_BLOCK_FIVE}</span><span class="s2"></span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_dsdt(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdt[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    int i,j;</span>
<span class="si">{ORDER_CODE_BLOCK_SIX}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_dsdp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdp[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    int i,j;</span>
<span class="si">{ORDER_CODE_BLOCK_SEVEN}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdn2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdn2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m, o;</span>
<span class="si">{ORDER_CODE_BLOCK_EIGHT}</span><span class="s2"></span>
<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">        dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdn2 cube */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NC}</span><span class="s2">; k++) {{</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[l] = d3gdn2ds[j][k][l];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) {{</span>
<span class="s2">                        temp[l] += d3gdnds2[j][l][m]*dsdn[m][k]</span>
<span class="s2">                        + d3gdnds2[k][l][m]*dsdn[m][j];</span>
<span class="s2">                        for (o=0; o&lt;</span><span class="si">{NS}</span><span class="s2">; o++)</span>
<span class="s2">                            temp[l] += d3gds3[l][m][o]*dsdn[m][j]*dsdn[o][k];</span>
<span class="s2">                    }}</span>
<span class="s2">                }}</span>
<span class="s2">                d2sdn2[i][j][k] = 0.0;</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) d2sdn2[i][j][k] += - invd2gds2[i][l]*temp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdndt(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdndt[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], dsdt[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m;</span>
<span class="si">{ORDER_CODE_BLOCK_NINE}</span><span class="s2"></span>

<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdndt matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[k] = d3gdndsdt[j][k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[k] += d3gdnds2[j][k][l]*dsdt[l] + d3gds2dt[k][l]*dsdn[l][j];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) temp[k] += d3gds3[k][l][m]*dsdn[l][j]*dsdt[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            d2sdndt[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) d2sdndt[i][j] += - invd2gds2[i][k]*temp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdndp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdndp[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m;</span>
<span class="si">{ORDER_CODE_BLOCK_TEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdndp matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[k] = d3gdndsdp[j][k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[k] += d3gdnds2[j][k][l]*dsdp[l] + d3gds2dp[k][l]*dsdn[l][j];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) temp[k] += d3gds3[k][l][m]*dsdn[l][j]*dsdp[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            d2sdndp[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) d2sdndp[i][j] += - invd2gds2[i][k]*temp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdt2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdt2[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdt[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_ELEVEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdt2 vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdt2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] +=  2.0*d3gds2dt[j][k]*dsdt[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdt[k]*dsdt[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdt2[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdt2[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdtdp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdtdp[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdt[</span><span class="si">{NS}</span><span class="s2">], dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_TWELVE}</span><span class="s2"></span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdtdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdtdp[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] += d3gds2dt[j][k]*dsdp[k] + d3gds2dp[j][k]*dsdt[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdt[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdtdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdtdp[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdp2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double s[</span><span class="si">{NS}</span><span class="s2">],</span>
<span class="s2">    double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdp2[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_THIRTEEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdp2 vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdp2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] +=  2.0*d3gds2dp[j][k]*dsdp[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdp[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdp2[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdp2[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">    </span><span class="se">\</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_complx_soln_calc_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_soln_calc_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_g(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{g_code}</span><span class="s2">;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dgdt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{dgdt_code}</span><span class="s2">;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dgdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{dgdp_code}</span><span class="s2">;</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_dgdn(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dgdn[</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    int i;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{dgdn_code}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) result[i] = dgdn[i];</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d2gdt2_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += 2.0*d2gdsdt[i]*dsdt[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) result += d2gds2[i][j]*dsdt[i]*dsdt[j];</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d2gdtdp_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += d2gdsdt[i]*dsdp[i] + d2gdsdp[i]*dsdt[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) result += d2gds2[i][j]*dsdt[i]*dsdp[j];</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d2gdndt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdndt[</span><span class="si">{number_components}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,k,l;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDNDT}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        result[i] = d2gdndt[i];</span>
<span class="s2">        for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">            result[i] += d2gdnds[i][k]*dsdt[k] + d2gdsdt[k]*dsdn[k][i];</span>
<span class="s2">            for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) result[i] += d2gds2[k][l]*dsdt[k]*dsdn[l][i];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d2gdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d2gdp2_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += 2.0*d2gdsdp[i]*dsdp[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) result += d2gds2[i][j]*dsdp[i]*dsdp[j];</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d2gdndp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdp[</span><span class="si">{number_ordering}</span><span class="s2">], dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdndp[</span><span class="si">{number_components}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,k,l;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDNDP}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        result[i] = d2gdndp[i];</span>
<span class="s2">        for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">            result[i] += d2gdnds[i][k]*dsdp[k] + d2gdsdp[k]*dsdn[k][i];</span>
<span class="s2">            for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) result[i] += d2gds2[k][l]*dsdp[k]*dsdn[l][i];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d2gdn2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdn2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l,m;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDN2}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="s2">    m = 0;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=i; j&lt;</span><span class="si">{number_components}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[m] = d2gdn2[i][j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[m] += d2gdnds[i][k]*dsdn[k][j] + d2gdnds[j][k]*dsdn[k][i];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) result[m] += d2gds2[k][l]*dsdn[k][i]*dsdn[l][j];</span>
<span class="s2">            }}</span>
<span class="s2">            m += 1;</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdt2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdt2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_d2sdt2(T, P, n, s, invd2gds2, d2sdt2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDSDT2}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d3gdt3_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += 3.0*d3gdsdt2[i]*dsdt[i] + 3.0*d2gdsdt[i]*d2sdt2[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result += 3.0*d2gds2[i][j]*dsdt[i]*d2sdt2[j]</span>
<span class="s2">                    + 3.0*d3gds2dt[i][j]*dsdt[i]*dsdt[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) result += d3gds3[i][j][k]*dsdt[i]*dsdt[j]*dsdt[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2sdt2[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdtdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdt2[</span><span class="si">{number_ordering}</span><span class="s2">], d3gdsdtdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_d2sdt2(T, P, n, s, invd2gds2, d2sdt2);</span>
<span class="s2">    order_d2sdtdp(T, P, n, s, invd2gds2, d2sdtdp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="si">{fillD3GDSDT2}</span><span class="s2"></span>
<span class="si">{fillD3GDSDTDP}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d3gdt2dp_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += d3gdsdt2[i]*dsdp[i] + 2.0*d2gdsdt[i]*d2sdtdp[i]</span>
<span class="s2">                + d2gdsdp[i]*d2sdt2[i] + 2.0*d3gdsdtdp[i]*dsdt[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result += 2.0*d3gds2dt[i][j]*dsdt[i]*dsdp[j]</span>
<span class="s2">                    + d2gds2[i][j]*d2sdt2[i]*dsdp[j]</span>
<span class="s2">                    + 2.0*d2gds2[i][j]*dsdt[i]*d2sdtdp[j]</span>
<span class="s2">                    + d3gds2dp[i][j]*dsdt[i]*dsdt[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) result += d3gds3[i][j][k]*dsdt[i]*dsdt[j]*dsdp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdndt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdt2[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdndt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdndt[</span><span class="si">{number_components}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdt[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndt2[</span><span class="si">{number_components}</span><span class="s2">], d3gdsdt2[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_d2sdt2(T, P, n, s, invd2gds2, d2sdt2);</span>
<span class="s2">    order_d2sdndt(T, P, n, s, invd2gds2, d2sdndt);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDNDT}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDNDT2}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDSDT2}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0,result[i]=d3gdndt2[i]; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[i] += d3gdsdt2[j]*dsdn[j][i] + 2.0*d2gdsdt[j]*d2sdndt[j][i]</span>
<span class="s2">                       + 2.0*d3gdndsdt[i][j]*dsdt[j] + d2gdnds[i][j]*d2sdt2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[i] += d3gdnds2[i][j][k]*dsdt[j]*dsdt[k]</span>
<span class="s2">                           + 2.0*d2gds2[j][k]*dsdt[j]*d2sdndt[k][i]</span>
<span class="s2">                           + 2.0*d3gds2dt[j][k]*dsdn[j][i]*dsdt[k]</span>
<span class="s2">                           + d2gds2[j][k]*dsdn[j][i]*d2sdt2[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++)</span>
<span class="s2">                    result[i] += d3gds3[j][k][l]*dsdn[j][i]*dsdt[k]*dsdt[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2sdp2[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdtdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdt2[</span><span class="si">{number_ordering}</span><span class="s2">], d3gdsdtdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdp2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_d2sdp2(T, P, n, s, invd2gds2, d2sdp2);</span>
<span class="s2">    order_d2sdtdp(T, P, n, s, invd2gds2, d2sdtdp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="si">{fillD3GDSDT2}</span><span class="s2"></span>
<span class="si">{fillD3GDSDTDP}</span><span class="s2"></span>
<span class="si">{fillD3GDSDP2}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d3gdtdp2_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += 2.0*d3gdsdtdp[i]*dsdp[i] + d2gdsdt[i]*d2sdp2[i]</span>
<span class="s2">                + 2.0*d2gdsdp[i]*d2sdtdp[i] + d3gdsdp2[i]*dsdt[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result += 2.0*d3gds2dp[i][j]*dsdt[i]*dsdp[j]</span>
<span class="s2">                    + d2gds2[i][j]*dsdt[i]*d2sdp2[j]</span>
<span class="s2">                    + 2.0*d2gds2[i][j]*d2sdtdp[i]*dsdp[j]</span>
<span class="s2">                    + d3gds2dt[i][j]*dsdp[i]*dsdp[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) result += d3gds3[i][j][k]*dsdt[i]*dsdp[j]*dsdp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdndtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdt[</span><span class="si">{number_ordering}</span><span class="s2">], dsdp[</span><span class="si">{number_ordering}</span><span class="s2">], dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdtdp[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdndt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdndp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdt[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdp[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndtdp[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdtdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_d2sdtdp(T, P, n, s, invd2gds2, d2sdtdp);</span>
<span class="s2">    order_d2sdndt(T, P, n, s, invd2gds2, d2sdndt);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDNDTDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDSDTDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0,result[i]=d3gdndtdp[i]; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[i] += d3gdsdtdp[j]*dsdn[j][i] + d2gdsdt[j]*d2sdndp[j][i]</span>
<span class="s2">                       + d3gdndsdt[i][j]*dsdp[j] + d2gdnds[i][j]*d2sdtdp[j]</span>
<span class="s2">                       + d3gdndsdp[i][j]*dsdt[j] + d2gdsdp[j]*d2sdndt[j][i];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[i] += d3gdnds2[i][j][k]*dsdt[j]*dsdp[k]</span>
<span class="s2">                           + d2gds2[j][k]*dsdt[j]*d2sdndp[k][i]</span>
<span class="s2">                           + d2gds2[j][k]*dsdp[j]*d2sdndt[k][i]</span>
<span class="s2">                           + d3gds2dt[j][k]*dsdn[j][i]*dsdp[k]</span>
<span class="s2">                           + d3gds2dp[j][k]*dsdn[j][i]*dsdt[k]</span>
<span class="s2">                           + d2gds2[j][k]*dsdn[j][i]*d2sdtdp[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++)</span>
<span class="s2">                    result[i] += d3gds3[j][k][l]*dsdn[j][i]*dsdt[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdn2dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">], dsdt[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2sdndt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdn2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdt[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdn2ds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdn2dt[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdt[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dt[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l,m,o;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_dsdt(T, P, n, s, invd2gds2, dsdt);</span>
<span class="s2">    order_d2sdn2(T, P, n, s, invd2gds2, d2sdn2);</span>
<span class="s2">    order_d2sdndt(T, P, n, s, invd2gds2, d2sdndt);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDN2DS}</span><span class="s2"></span>
<span class="si">{fillD3GDN2DT}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDT}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DT}</span><span class="s2"></span>
<span class="s2">    o = 0;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=i; j&lt;</span><span class="si">{number_components}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[o] = d3gdn2dt[i][j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[o] += d3gdn2ds[i][j][k]*dsdt[k]</span>
<span class="s2">                              + d3gdndsdt[i][k]*dsdn[k][j]</span>
<span class="s2">                              + d3gdndsdt[j][k]*dsdn[k][i]</span>
<span class="s2">                              + d2gdsdt[k]*d2sdn2[k][i][j]</span>
<span class="s2">                              + d2gdnds[i][k]*d2sdndt[k][j]</span>
<span class="s2">                              + d2gdnds[j][k]*d2sdndt[k][i];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) {{</span>
<span class="s2">                    result[o] += d3gdnds2[i][k][l]*dsdn[k][j]*dsdt[l]</span>
<span class="s2">                                  + d3gdnds2[j][k][l]*dsdn[k][i]*dsdt[l]</span>
<span class="s2">                                  + d2gds2[k][l]*d2sdn2[k][i][j]*dsdt[l]</span>
<span class="s2">                                  + d3gds2dt[k][l]*dsdn[k][i]*dsdn[l][j]</span>
<span class="s2">                                  + d2gds2[k][l]*dsdn[k][i]*d2sdndt[l][j]</span>
<span class="s2">                                  + d2gds2[k][l]*dsdn[k][j]*d2sdndt[l][i];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{number_ordering}</span><span class="s2">; m++)</span>
<span class="s2">                        result[o] += d3gds3[k][l][m]*dsdn[k][i]*dsdn[l][j]*dsdt[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            o += 1;</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_d3gdp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdp[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdp2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdp2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_d2sdp2(T, P, n, s, invd2gds2, d2sdp2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="si">{fillD3GDSDP2}</span><span class="s2"></span>
<span class="s2">    double result = </span><span class="si">{d3gdp3_code}</span><span class="s2">;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_ordering}</span><span class="s2">; i++) {{</span>
<span class="s2">        result += 3.0*d3gdsdp2[i]*dsdp[i] + 3.0*d2gdsdp[i]*d2sdp2[i];</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result += 3.0*d2gds2[i][j]*dsdp[i]*d2sdp2[j]</span>
<span class="s2">                    + 3.0*d3gds2dp[i][j]*dsdp[i]*dsdp[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) result += d3gds3[i][j][k]*dsdp[i]*dsdp[j]*dsdp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    return result;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdndp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdp[</span><span class="si">{number_ordering}</span><span class="s2">], dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdp2[</span><span class="si">{number_ordering}</span><span class="s2">], d2sdndp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gdndp[</span><span class="si">{number_components}</span><span class="s2">], d3gdndp2[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdp[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdsdp2[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_d2sdp2(T, P, n, s, invd2gds2, d2sdp2);</span>
<span class="s2">    order_d2sdndp(T, P, n, s, invd2gds2, d2sdndp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDNDP}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDNDP2}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="si">{fillD3GDSDP2}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0,result[i]=d3gdndp2[i]; j&lt;</span><span class="si">{number_ordering}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[i] += d3gdsdp2[j]*dsdn[j][i] + 2.0*d2gdsdp[j]*d2sdndp[j][i]</span>
<span class="s2">                       + 2.0*d3gdndsdp[i][j]*dsdp[j] + d2gdnds[i][j]*d2sdp2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[i] += d3gdnds2[i][j][k]*dsdp[j]*dsdp[k]</span>
<span class="s2">                           + 2.0*d2gds2[j][k]*dsdp[j]*d2sdndp[k][i]</span>
<span class="s2">                           + 2.0*d3gds2dp[j][k]*dsdn[j][i]*dsdp[k]</span>
<span class="s2">                           + d2gds2[j][k]*dsdn[j][i]*d2sdp2[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++)</span>
<span class="s2">                    result[i] += d3gds3[j][k][l]*dsdn[j][i]*dsdp[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdn2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">], dsdp[</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double d2sdndp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdn2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">], d2gdsdp[</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdn2ds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdn2dp[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdndsdp[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds2dp[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l,m,o;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_dsdp(T, P, n, s, invd2gds2, dsdp);</span>
<span class="s2">    order_d2sdn2(T, P, n, s, invd2gds2, d2sdn2);</span>
<span class="s2">    order_d2sdndp(T, P, n, s, invd2gds2, d2sdndp);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD2GDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDN2DS}</span><span class="s2"></span>
<span class="si">{fillD3GDN2DP}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDNDSDP}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="si">{fillD3GDS2DP}</span><span class="s2"></span>
<span class="s2">    o = 0;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=i; j&lt;</span><span class="si">{number_components}</span><span class="s2">; j++) {{</span>
<span class="s2">            result[o] = d3gdn2dp[i][j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{number_ordering}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[o] += d3gdn2ds[i][j][k]*dsdp[k]</span>
<span class="s2">                              + d3gdndsdp[i][k]*dsdn[k][j]</span>
<span class="s2">                              + d3gdndsdp[j][k]*dsdn[k][i]</span>
<span class="s2">                              + d2gdsdp[k]*d2sdn2[k][i][j]</span>
<span class="s2">                              + d2gdnds[i][k]*d2sdndp[k][j]</span>
<span class="s2">                              + d2gdnds[j][k]*d2sdndp[k][i];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) {{</span>
<span class="s2">                    result[o] += d3gdnds2[i][k][l]*dsdn[k][j]*dsdp[l]</span>
<span class="s2">                                  + d3gdnds2[j][k][l]*dsdn[k][i]*dsdp[l]</span>
<span class="s2">                                  + d2gds2[k][l]*d2sdn2[k][i][j]*dsdp[l]</span>
<span class="s2">                                  + d3gds2dp[k][l]*dsdn[k][i]*dsdn[l][j]</span>
<span class="s2">                                  + d2gds2[k][l]*dsdn[k][i]*d2sdndp[l][j]</span>
<span class="s2">                                  + d2gds2[k][l]*dsdn[k][j]*d2sdndp[l][i];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{number_ordering}</span><span class="s2">; m++)</span>
<span class="s2">                        result[o] += d3gds3[k][l][m]*dsdn[k][i]*dsdn[l][j]*dsdp[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            o += 1;</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d3gdn3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    </span><span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    double dsdn[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2sdn2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">];</span>
<span class="s2">    double d2gdnds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdn3[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">           d3gdn2ds[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gdnds2[</span><span class="si">{number_components}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">],</span>
<span class="s2">           d3gds3[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    int i,j,k,l,m,q,o;</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="s2">    order_dsdn(T, P, n, s, invd2gds2, dsdn);</span>
<span class="s2">    order_d2sdn2(T, P, n, s, invd2gds2, d2sdn2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="si">{fillD2GDNDS}</span><span class="s2"></span>
<span class="si">{fillD2GDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDN3}</span><span class="s2"></span>
<span class="si">{fillD3GDN2DS}</span><span class="s2"></span>
<span class="si">{fillD3GDNDS2}</span><span class="s2"></span>
<span class="si">{fillD3GDS3}</span><span class="s2"></span>
<span class="s2">    o = 0;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=i; j&lt;</span><span class="si">{number_components}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=j; k&lt;</span><span class="si">{number_components}</span><span class="s2">; k++) {{</span>
<span class="s2">                result[o] = d3gdn3[i][j][k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{number_ordering}</span><span class="s2">; l++) {{</span>
<span class="s2">                    result[o] += d3gdn2ds[i][j][l]*dsdn[l][k]</span>
<span class="s2">                               + d3gdn2ds[j][k][l]*dsdn[l][i]</span>
<span class="s2">                               + d3gdn2ds[k][i][l]*dsdn[l][j];</span>
<span class="s2">                    result[o] += d2gdnds[i][l]*d2sdn2[l][j][k]</span>
<span class="s2">                               + d2gdnds[j][l]*d2sdn2[l][i][k]</span>
<span class="s2">                               + d2gdnds[k][l]*d2sdn2[l][j][i];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{number_ordering}</span><span class="s2">; m++) {{</span>
<span class="s2">                        result[o] += d3gdnds2[i][l][m]*dsdn[l][j]*dsdn[m][k]</span>
<span class="s2">                                   + d3gdnds2[j][l][m]*dsdn[l][k]*dsdn[m][i]</span>
<span class="s2">                                   + d3gdnds2[k][l][m]*dsdn[l][i]*dsdn[m][j];</span>
<span class="s2">                        result[o] += d2gds2[l][m]*d2sdn2[l][j][k]*dsdn[m][i]</span>
<span class="s2">                                   + d2gds2[l][m]*d2sdn2[l][i][k]*dsdn[m][j]</span>
<span class="s2">                                   + d2gds2[l][m]*d2sdn2[l][i][j]*dsdn[m][k];</span>
<span class="s2">                        for (q=0; q&lt;</span><span class="si">{number_ordering}</span><span class="s2">; q++)</span>
<span class="s2">                            result[o] += d3gds3[l][m][q]*dsdn[l][i]*dsdn[m][j]*dsdn[q][k];</span>
<span class="s2">                    }}</span>
<span class="s2">                }}</span>
<span class="s2">                o += 1;</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdndt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdndt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdndtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdndp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_components}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_components}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdn2dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdn2dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdn2dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn2dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn2dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn2dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn2dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_hessian_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdn3dt(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d4gdn3dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn3dt2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn3dtdp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d5gdn3dp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d6gdn3dt3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d6gdn3dt2dp(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d6gdn3dtdp2(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">static void </span><span class="si">{module}</span><span class="s2">_d6gdn3dp3(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">],</span>
<span class="s2">    double result[</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">]) {{</span>
<span class="s2">    int i;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{number_symmetric_tensor_terms}</span><span class="s2">; i++) result[i] = 0.0;</span>
<span class="s2">}}</span>

<span class="s2">    </span><span class="se">\</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_complx_soln_calib_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_complx_soln_calib_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="si">{extra_ordering_code}</span><span class="s2"></span>

<span class="s2">static double </span><span class="si">{module}</span><span class="s2">_dparam_</span><span class="si">{func}</span><span class="s2">(double T, double P, double n[</span><span class="si">{number_components}</span><span class="s2">], int index) {{</span>
<span class="si">{moles_assign}</span><span class="s2"></span>
<span class="s2">    static double s[</span><span class="si">{number_ordering}</span><span class="s2">] = </span><span class="si">{order_initial_guess}</span><span class="s2">;</span>
<span class="s2">    double invd2gds2[</span><span class="si">{number_ordering}</span><span class="s2">][</span><span class="si">{number_ordering}</span><span class="s2">];</span>
<span class="s2">    order_s(T, P, n, s, invd2gds2);</span>
<span class="si">{order_assign}</span><span class="s2"></span>
<span class="s2">    double result = 0.0;</span>
<span class="s2">    switch (index) {{</span>
<span class="si">{switch_code}</span><span class="s2"></span>
<span class="s2">    default:</span>
<span class="s2">        break;</span>
<span class="s2">    }}</span>
<span class="s2">        return result;</span>
<span class="s2">}}</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_speciation_code_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_speciation_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#include &lt;stdlib.h&gt;</span>
<span class="s2">#include &lt;stdio.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_vector.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_matrix.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_multiroots.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_permutation.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_linalg.h&gt;</span>
<span class="s2">#include &lt;gsl/gsl_cblas.h&gt;</span>

<span class="s2">extern int nnlsWithConstraintMatrix(double **a, int m, int n, double *b, double *x, double *rnorm,</span>
<span class="s2">    double *w, double *zz, int *index, int debug);</span>

<span class="s2">#undef MAX</span>
<span class="s2">#undef MIN</span>

<span class="s2">#define MAX(a,b)  ((a) &gt; (b) ? (a) : (b))</span>
<span class="s2">#define MIN(a,b)  ((a) &lt; (b) ? (a) : (b))</span>

<span class="s2">#define SQUARE(x) ((x)*(x))</span>

<span class="s2">#ifndef TRUE</span>
<span class="s2">#define TRUE 1</span>
<span class="s2">#endif</span>

<span class="s2">#ifndef FALSE</span>
<span class="s2">#define FALSE 0</span>
<span class="s2">#endif</span>

<span class="s2">struct system_params {{</span>
<span class="s2">    gsl_vector *e;</span>
<span class="s2">    gsl_vector *lnQ;</span>
<span class="s2">    gsl_matrix *R;</span>
<span class="s2">    gsl_matrix *Cb;</span>
<span class="s2">    gsl_matrix *Cs;</span>
<span class="s2">}};</span>

<span class="s2">static int system_f(const gsl_vector *y, void *params, gsl_vector *f) {{</span>
<span class="s2">  gsl_vector *e   = ((struct system_params *) params)-&gt;e;</span>
<span class="s2">  gsl_vector *lnQ = ((struct system_params *) params)-&gt;lnQ;</span>
<span class="s2">  gsl_matrix *R   = ((struct system_params *) params)-&gt;R;</span>
<span class="s2">  gsl_matrix *Cb  = ((struct system_params *) params)-&gt;Cb;</span>
<span class="s2">  gsl_matrix *Cs  = ((struct system_params *) params)-&gt;Cs;</span>
<span class="s2">  int ne = e-&gt;size;</span>
<span class="s2">  int ns = lnQ-&gt;size;</span>
<span class="s2">  int nv = y-&gt;size-1;</span>
<span class="s2">  double nT = exp(y-&gt;data[y-&gt;size-1]);</span>

<span class="s2">  gsl_vector *prod = gsl_vector_alloc(lnQ-&gt;size);</span>

<span class="s2">  for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">    double sum = gsl_vector_get(lnQ, i);</span>
<span class="s2">    for (int j=0; j&lt;nv; j++) sum += gsl_matrix_get(R, i, j)*y-&gt;data[j];</span>
<span class="s2">    gsl_vector_set(prod, i, exp(sum));</span>
<span class="s2">  }}</span>

<span class="s2">  for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">    double sum = 0.0;</span>
<span class="s2">    for (int j=0; j&lt;ne; j++) sum += gsl_matrix_get(Cb, j, i)*exp(y-&gt;data[j]);</span>
<span class="s2">    for (int j=0; j&lt;ns; j++) sum += gsl_matrix_get(Cs, j, i)*prod-&gt;data[j];</span>
<span class="s2">    gsl_vector_set(f, i, nT*sum - e-&gt;data[i]);</span>
<span class="s2">  }}</span>

<span class="s2">  double Xsum = 0.0;</span>
<span class="s2">  for (int i=0; i&lt;ne; i++) Xsum += exp(y-&gt;data[i]);</span>
<span class="s2">  for (int i=0; i&lt;ns; i++) Xsum += prod-&gt;data[i];</span>
<span class="s2">  gsl_vector_set(f, ne, Xsum - 1.0);</span>

<span class="s2">  gsl_vector_free(prod);</span>
<span class="s2">  return GSL_SUCCESS;</span>
<span class="s2">}}</span>

<span class="s2">static int system_df(const gsl_vector *y, void *params, gsl_matrix *J) {{</span>
<span class="s2">  gsl_vector *e   = ((struct system_params *) params)-&gt;e;</span>
<span class="s2">  gsl_vector *lnQ = ((struct system_params *) params)-&gt;lnQ;</span>
<span class="s2">  gsl_matrix *R   = ((struct system_params *) params)-&gt;R;</span>
<span class="s2">  gsl_matrix *Cb  = ((struct system_params *) params)-&gt;Cb;</span>
<span class="s2">  gsl_matrix *Cs  = ((struct system_params *) params)-&gt;Cs;</span>
<span class="s2">  int ne = e-&gt;size;</span>
<span class="s2">  int ns = lnQ-&gt;size;</span>
<span class="s2">  int nv = y-&gt;size-1;</span>
<span class="s2">  double nT = exp(y-&gt;data[y-&gt;size-1]);</span>

<span class="s2">  gsl_vector *prod = gsl_vector_alloc(lnQ-&gt;size);</span>

<span class="s2">  for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">    double sum = gsl_vector_get(lnQ, i);</span>
<span class="s2">    for (int j=0; j&lt;nv; j++) sum += gsl_matrix_get(R, i, j)*y-&gt;data[j];</span>
<span class="s2">    gsl_vector_set(prod, i, exp(sum));</span>
<span class="s2">  }}</span>

<span class="s2">  for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">    for (int j=0; j&lt;ne; j++) {{</span>
<span class="s2">      double sum = gsl_matrix_get(Cb, i, j)*exp(y-&gt;data[j]);</span>
<span class="s2">      for (int k=0; k&lt;ns; k++) {{</span>
<span class="s2">        sum +=  gsl_matrix_get(R, k, i)*prod-&gt;data[k]*gsl_matrix_get(Cs, k, j);</span>
<span class="s2">      }}</span>
<span class="s2">      gsl_matrix_set (J, i, j, nT*sum);</span>
<span class="s2">    }}</span>
<span class="s2">    double sum = 0.0;</span>
<span class="s2">    for (int j=0; j&lt;ne; j++) sum += gsl_matrix_get(Cb, j, i)*exp(y-&gt;data[j]);</span>
<span class="s2">    for (int j=0; j&lt;ns; j++) sum += gsl_matrix_get(Cs, j, i)*prod-&gt;data[j];</span>
<span class="s2">    gsl_matrix_set(J, i, ne, nT*sum);</span>
<span class="s2">  }}</span>

<span class="s2">  for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">    double Xsum = exp(y-&gt;data[i]);</span>
<span class="s2">    for (int j=0; j&lt;ns; j++) Xsum += gsl_matrix_get(R, j, i)*prod-&gt;data[j];</span>
<span class="s2">    gsl_matrix_set(J, ne, i, Xsum);</span>
<span class="s2">  }}</span>
<span class="s2">  gsl_matrix_set(J, ne, ne, 0.0);</span>

<span class="s2">  gsl_vector_free(prod);</span>
<span class="s2">  return GSL_SUCCESS;</span>
<span class="s2">}}</span>

<span class="s2">static int system_fdf(const gsl_vector *y, void *params, gsl_vector *f, gsl_matrix *J) {{</span>
<span class="s2">  gsl_vector *e   = ((struct system_params *) params)-&gt;e;</span>
<span class="s2">  gsl_vector *lnQ = ((struct system_params *) params)-&gt;lnQ;</span>
<span class="s2">  gsl_matrix *R   = ((struct system_params *) params)-&gt;R;</span>
<span class="s2">  gsl_matrix *Cb  = ((struct system_params *) params)-&gt;Cb;</span>
<span class="s2">  gsl_matrix *Cs  = ((struct system_params *) params)-&gt;Cs;</span>
<span class="s2">  int ne = e-&gt;size;</span>
<span class="s2">  int ns = lnQ-&gt;size;</span>
<span class="s2">  int nv = y-&gt;size-1;</span>
<span class="s2">  double nT = exp(y-&gt;data[y-&gt;size-1]);</span>

<span class="s2">  gsl_vector *prod = gsl_vector_alloc(lnQ-&gt;size);</span>

<span class="s2">  for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">    double sum = gsl_vector_get(lnQ, i);</span>
<span class="s2">    for (int j=0; j&lt;nv; j++) sum += gsl_matrix_get(R, i, j)*y-&gt;data[j];</span>
<span class="s2">    gsl_vector_set(prod, i, exp(sum));</span>
<span class="s2">  }}</span>

<span class="s2">  for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">    double sum = 0.0;</span>
<span class="s2">    for (int j=0; j&lt;ne; j++) sum += gsl_matrix_get(Cb, j, i)*exp(y-&gt;data[j]);</span>
<span class="s2">    for (int j=0; j&lt;ns; j++) sum += gsl_matrix_get(Cs, j, i)*prod-&gt;data[j];</span>
<span class="s2">    gsl_vector_set(f, i, nT*sum - e-&gt;data[i]);</span>
<span class="s2">    gsl_matrix_set(J, i, ne, nT*sum);</span>

<span class="s2">    for (int j=0; j&lt;ne; j++) {{</span>
<span class="s2">      double sum = gsl_matrix_get(Cb, i, j)*exp(y-&gt;data[j]);</span>
<span class="s2">      for (int k=0; k&lt;ns; k++) {{</span>
<span class="s2">        sum +=  gsl_matrix_get(R, k, i)*prod-&gt;data[k]*gsl_matrix_get(Cs, k, j);</span>
<span class="s2">      }}</span>
<span class="s2">      gsl_matrix_set (J, i, j, nT*sum);</span>
<span class="s2">    }}</span>
<span class="s2">  }}</span>

<span class="s2">  double Xsum = 0.0;</span>
<span class="s2">  for (int i=0; i&lt;ne; i++) Xsum += exp(y-&gt;data[i]);</span>
<span class="s2">  for (int i=0; i&lt;ns; i++) Xsum += prod-&gt;data[i];</span>
<span class="s2">  gsl_vector_set(f, ne, Xsum - 1.0);</span>

<span class="s2">  for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">    double Xsum = exp(y-&gt;data[i]);</span>
<span class="s2">    for (int j=0; j&lt;ns; j++) Xsum += gsl_matrix_get(R, j, i)*prod-&gt;data[j];</span>
<span class="s2">    gsl_matrix_set(J, ne, i, Xsum);</span>
<span class="s2">  }}</span>
<span class="s2">  gsl_matrix_set(J, ne, ne, 0.0);</span>

<span class="s2">  gsl_vector_free(prod);</span>
<span class="s2">  return GSL_SUCCESS;</span>
<span class="s2">}}</span>

<span class="s2">static void print_state (size_t iter, gsl_multiroot_fdfsolver *s) {{</span>
<span class="s2">  printf (&quot;iter = </span><span class="si">%3lu</span><span class="se">\\</span><span class="s2">n&quot;, iter);</span>
<span class="s2">  for (size_t i=0; i&lt;s-&gt;x-&gt;size; i+=8) {{</span>
<span class="s2">    printf (&quot;Solution:</span><span class="se">\\</span><span class="s2">n&quot;);</span>
<span class="s2">    for (size_t j=i*8; j&lt;MIN(i*8+8, s-&gt;x-&gt;size); j++) printf(&quot; </span><span class="si">%10.3e</span><span class="s2">&quot;, gsl_vector_get (s-&gt;x, j));</span>
<span class="s2">    printf (&quot;</span><span class="se">\\</span><span class="s2">nFunction:</span><span class="se">\\</span><span class="s2">n&quot;);</span>
<span class="s2">    for (size_t j=i*8; j&lt;MIN(i*8+8, s-&gt;x-&gt;size); j++) printf(&quot; </span><span class="si">%10.3e</span><span class="s2">&quot;, gsl_vector_get (s-&gt;f, j));</span>
<span class="s2">    printf (&quot;</span><span class="se">\\</span><span class="s2">n&quot;);</span>
<span class="s2">  }}</span>
<span class="s2">}}</span>

<span class="s2">#define ne </span><span class="si">{number_components}</span><span class="s2"></span>
<span class="s2">#define ns </span><span class="si">{number_non_basis}</span><span class="s2"></span>

<span class="s2">static void compute_lnQ(double t, double p, struct system_params *params) {{</span>
<span class="s2">    // compute mu&#39;s and get lnQ from R: lnQ = -(mu0_s - np.matmul(R,mu0_b))/(8.3143*t)</span>
<span class="s2">    double mu0_b[ne];</span>
<span class="s2">    for (int i=0; i&lt;ne; i++) mu0_b[i] = endmember[i].mu0(t, p);</span>
<span class="s2">    for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">        double sum = endmember[i+ne].mu0(t, p);</span>
<span class="s2">        for (int j=0; j&lt;ne; j++) {{</span>
<span class="s2">            sum -= gsl_matrix_get(params-&gt;R, i, j)*mu0_b[j];</span>
<span class="s2">        }}</span>
<span class="s2">        gsl_vector_set(params-&gt;lnQ, i, -sum/(8.3143*t));</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void gaussj(double a[ns][ns]);</span>

<span class="s2">static int speciate(double t, double p, double*e, double *b, double *s,</span>
<span class="s2">    double invd2gds2[ns][ns], int debug) {{</span>
<span class="s2">    static struct system_params params;</span>
<span class="s2">    static int first = TRUE;</span>
<span class="s2">    static gsl_vector *lnX;</span>
<span class="s2">    static double tOld, pOld, eOld[ne], bOld[ne], sOld[ns], invd2gds2Old[ns][ns];</span>
<span class="s2">    if (!first) {{</span>
<span class="s2">        int same  = (fabs(t-tOld) &lt; 1.0e-2);</span>
<span class="s2">            same &amp;= (fabs(p-pOld) &lt; 1.0e-2);</span>
<span class="s2">        for (int i=0; i&lt;ne; i++) same &amp;= (fabs(e[i]-eOld[i]) &lt; 1.0e-7);</span>
<span class="s2">        if (same) {{</span>
<span class="s2">            for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">                b[i] = bOld[i];</span>
<span class="s2">            }}</span>
<span class="s2">            for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">                s[i] = sOld[i];</span>
<span class="s2">                for (int j=0; j&lt;ns; j++) invd2gds2[i][j] = invd2gds2Old[i][j];</span>
<span class="s2">            }}</span>
<span class="s2">            return TRUE;</span>
<span class="s2">        }}</span>
<span class="s2">    }} else {{</span>
<span class="s2">        first = FALSE;</span>
<span class="s2">        params.e   = gsl_vector_alloc(ne);</span>
<span class="s2">        params.lnQ = gsl_vector_alloc(ns);</span>
<span class="s2">        params.R   = gsl_matrix_alloc(ns, ne);</span>
<span class="s2">        params.Cb  = gsl_matrix_alloc(ne, ne);</span>
<span class="s2">        params.Cs  = gsl_matrix_alloc(ns, ne);</span>
<span class="s2">        lnX = gsl_vector_alloc(ne+1);</span>
<span class="s2">        //</span>
<span class="s2">        // Fill Cb, Cs matrices for this case</span>
<span class="si">{fill_Cb}</span><span class="s2"></span>
<span class="si">{fill_Cs}</span><span class="s2"></span>
<span class="s2">        gsl_matrix *CbInv = gsl_matrix_alloc(ne, ne);</span>
<span class="s2">        gsl_permutation *perm  = gsl_permutation_alloc(ne);</span>
<span class="s2">        gsl_permutation_init(perm);</span>
<span class="s2">        gsl_linalg_LU_invert(params.Cb, perm, CbInv);</span>
<span class="s2">        gsl_permutation_free(perm);</span>
<span class="s2">        gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, params.Cs, CbInv, 0.0, params.R);</span>
<span class="s2">        gsl_matrix_free(CbInv);</span>
<span class="s2">    }}</span>
<span class="s2">    // Fill lnQ for this case using R</span>
<span class="s2">    // compute mu&#39;s and get lnQ from R: lnQ = -(mu0_s - np.matmul(R,mu0_b))/(8.3143*t)</span>
<span class="s2">    compute_lnQ(t, p, &amp;params);</span>
<span class="s2">    if (debug) {{</span>
<span class="s2">        for (int i=0; i&lt;ns; i++) printf(&quot;lnQ[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%10.3e</span><span class="se">\\</span><span class="s2">n&quot;, i,</span>
<span class="s2">            gsl_vector_get(params.lnQ, i));</span>
<span class="s2">    }}</span>
<span class="s2">    // Now compute an initial guess</span>
<span class="s2">    double **aNNLS = (double **) malloc((size_t) ns*sizeof(double *));</span>
<span class="s2">    double  *bNNLS = (double *)  malloc((size_t) ns*sizeof(double));</span>
<span class="s2">    double  *xNNLS = (double *)  malloc((size_t) (ne+ns)*sizeof(double));</span>
<span class="s2">    double  *wNNLS = (double *)  malloc((size_t) (ne+ns)*sizeof(double));</span>
<span class="s2">    double *zzNNLS = (double *)  malloc((size_t) ns*sizeof(double));</span>
<span class="s2">    int *indexNNLS = (int *)     malloc((size_t) (ne+ns)*sizeof(int));</span>
<span class="s2">    double rNorm=0.0;</span>
<span class="s2">    for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">        bNNLS[i] = -gsl_vector_get(params.lnQ, i);</span>
<span class="s2">        aNNLS[i] = (double *) malloc((size_t) (ne+ns)*sizeof(double));</span>
<span class="s2">        for (int j=0; j&lt;ne; j++) {{</span>
<span class="s2">            aNNLS[i][j]    = -gsl_matrix_get(params.R, i, j);</span>
<span class="s2">        }}</span>
<span class="s2">        for (int j=0; j&lt;ns; j++) {{</span>
<span class="s2">            aNNLS[i][ne+j] = (i == j) ? 1.0 : 0.0;</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    int success = nnlsWithConstraintMatrix(aNNLS, ns, ne+ns, bNNLS, xNNLS, &amp;rNorm,</span>
<span class="s2">        wNNLS, zzNNLS, indexNNLS, debug);</span>
<span class="s2">    if (!success) printf(&quot;Speciate error. Failure in initial guess routine (NNLS).</span><span class="se">\\</span><span class="s2">n&quot;);</span>
<span class="s2">    if (debug) {{</span>
<span class="s2">        printf (&quot;NNLS solution: (rNorm = </span><span class="si">%10.3e</span><span class="s2">)</span><span class="se">\\</span><span class="s2">n&quot;, rNorm);</span>
<span class="s2">        for (int i=0; i&lt;ne+ns; i++) printf (&quot; </span><span class="si">%10.2e</span><span class="s2">&quot;, xNNLS[i]);</span>
<span class="s2">        printf (&quot;</span><span class="se">\\</span><span class="s2">n&quot;);</span>
<span class="s2">    }}</span>
<span class="s2">    for (int i=0; i&lt;ne; i++) gsl_vector_set(lnX, i, -xNNLS[i]);</span>
<span class="s2">    for (int i=0; i&lt;ns; i++) free(aNNLS[i]);</span>
<span class="s2">    free (aNNLS); free(bNNLS); free(xNNLS); free(wNNLS); free(zzNNLS); free(indexNNLS);</span>

<span class="s2">    // compute mu&#39;s and get lnQ from R: lnQ = -(mu0_s - np.matmul(R,mu0_b))/(8.3143*t)</span>
<span class="s2">    compute_lnQ(t, p, &amp;params);</span>
<span class="s2">    if (debug) {{</span>
<span class="s2">        for (int i=0; i&lt;ns; i++) printf(&quot;lnQ[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%10.3e</span><span class="se">\\</span><span class="s2">n&quot;, i,</span>
<span class="s2">            gsl_vector_get(params.lnQ, i));</span>
<span class="s2">    }}</span>

<span class="s2">    // set e</span>
<span class="s2">    double nT = 0.0;</span>
<span class="s2">    for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">        gsl_vector_set(params.e, i, e[i]);</span>
<span class="s2">        nT += e[i];</span>
<span class="s2">    }}</span>
<span class="s2">    gsl_vector_set(lnX, ne, log(nT));</span>

<span class="s2">    // options:</span>
<span class="s2">    // gsl_multiroot_fdfsolver_hybridsj</span>
<span class="s2">    // gsl_multiroot_fdfsolver_hybridj</span>
<span class="s2">    // gsl_multiroot_fdfsolver_newton</span>
<span class="s2">    // gsl_multiroot_fdfsolver_gnewton</span>
<span class="s2">    const gsl_multiroot_fdfsolver_type *Tgsl = </span><span class="si">{gsl_multiroot_method}</span><span class="s2">;</span>
<span class="s2">    gsl_multiroot_fdfsolver *soln = gsl_multiroot_fdfsolver_alloc (Tgsl, ne+1);</span>
<span class="s2">    int status;</span>
<span class="s2">    size_t iter = 0;</span>

<span class="s2">    gsl_multiroot_function_fdf f = {{&amp;system_f, &amp;system_df, &amp;system_fdf, ne+1, &amp;params}};</span>
<span class="s2">    gsl_multiroot_fdfsolver_set (soln, &amp;f, lnX);</span>

<span class="s2">    if (debug) print_state (iter, soln);</span>

<span class="s2">    do {{</span>
<span class="s2">        iter++;</span>
<span class="s2">        status = gsl_multiroot_fdfsolver_iterate (soln);</span>
<span class="s2">        if (debug) print_state (iter, soln);</span>
<span class="s2">        if (status) break;</span>
<span class="s2">        gsl_vector *x  = gsl_multiroot_fdfsolver_root(soln);</span>
<span class="s2">        gsl_vector *f  = gsl_multiroot_fdfsolver_f(soln);</span>
<span class="s2">        gsl_vector *dx = gsl_multiroot_fdfsolver_dx(soln);</span>
<span class="s2">        if (debug) {{</span>
<span class="s2">            for (int i=0; i&lt;(ne+1); i++) {{</span>
<span class="s2">                printf (&quot;</span><span class="si">%3d</span><span class="s2"> f = </span><span class="si">%13.6g</span><span class="s2"> x = </span><span class="si">%13.6g</span><span class="s2"> dx = </span><span class="si">%13.6g</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">                   i, gsl_vector_get(f, i), gsl_vector_get(x, i), gsl_vector_get(dx, i));</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        // status = gsl_multiroot_test_residual (f, 1.e-7);</span>
<span class="s2">        status = gsl_multiroot_test_delta (dx, x, 1.e-7, 1.e-10);</span>
<span class="s2">    }} while (status == GSL_CONTINUE &amp;&amp; iter &lt; 50);</span>

<span class="s2">    // Outputs:</span>
<span class="s2">    // gsl_vector * gsl_multiroot_fdfsolver_root(const gsl_multiroot_fdfsolver * soln)</span>
<span class="s2">    // gsl_vector * gsl_multiroot_fdfsolver_f(const gsl_multiroot_fdfsolver * soln)</span>
<span class="s2">    // gsl_vector * gsl_multiroot_fdfsolver_dx(const gsl_multiroot_fdfsolver * soln)</span>
<span class="s2">    // gsl_multiroot_test_delta(const gsl_vector * dx, const gsl_vector * x, double epsabs, double epsrel)</span>

<span class="s2">    if (debug) {{</span>
<span class="s2">        printf (&quot;status = </span><span class="si">%s</span><span class="se">\\</span><span class="s2">n&quot;, gsl_strerror (status));</span>
<span class="s2">        print_state(iter, soln);</span>
<span class="s2">    }}</span>

<span class="s2">    gsl_vector *lnQ = params.lnQ;</span>
<span class="s2">    gsl_matrix *R   = params.R;</span>
<span class="s2">    for (int i=0; i&lt;ne; i++) b[i] = exp(gsl_vector_get (soln-&gt;x, i));</span>
<span class="s2">    for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">        double sum = gsl_vector_get(lnQ, i);</span>
<span class="s2">        for (int j=0; j&lt;ne; j++) sum += gsl_matrix_get(R, i, j)*gsl_vector_get (soln-&gt;x, j);</span>
<span class="s2">        s[i] = exp(sum);</span>
<span class="s2">    }}</span>

<span class="si">{fill_invd2gds2}</span><span class="s2"></span>

<span class="s2">    if (debug) {{</span>
<span class="s2">        double eT = 0.0;</span>
<span class="s2">        for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">            printf (&quot;e[</span><span class="si">%d</span><span class="s2">]  = </span><span class="si">%g</span><span class="se">\\</span><span class="s2">n&quot;, i, e[i]);</span>
<span class="s2">            eT += e[i];</span>
<span class="s2">        }}</span>
<span class="s2">        printf (&quot;eT    = </span><span class="si">%g</span><span class="se">\\</span><span class="s2">n&quot;, eT);</span>
<span class="s2">        double Xsum = 0.0;</span>
<span class="s2">        for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">            printf (&quot;Xb[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%g</span><span class="se">\\</span><span class="s2">n&quot;, i, exp(gsl_vector_get (soln-&gt;x, i)));</span>
<span class="s2">            Xsum += exp(gsl_vector_get (soln-&gt;x, i));</span>
<span class="s2">        }}</span>
<span class="s2">        gsl_vector *lnQ = params.lnQ;</span>
<span class="s2">        gsl_matrix *R   = params.R;</span>
<span class="s2">        for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">          double sum = gsl_vector_get(lnQ, i);</span>
<span class="s2">          for (int j=0; j&lt;ne; j++) sum += gsl_matrix_get(R, i, j)*gsl_vector_get (soln-&gt;x, j);</span>
<span class="s2">          printf (&quot;Xs[</span><span class="si">%d</span><span class="s2">] = </span><span class="si">%g</span><span class="se">\\</span><span class="s2">n&quot;, i, exp(sum));</span>
<span class="s2">          Xsum += exp(sum);</span>
<span class="s2">        }}</span>
<span class="s2">        printf (&quot;Xsum  = </span><span class="si">%g</span><span class="se">\\</span><span class="s2">n&quot;, Xsum);</span>
<span class="s2">    }}</span>

<span class="s2">    tOld = t;</span>
<span class="s2">    pOld = p;</span>
<span class="s2">    for (int i=0; i&lt;ne; i++) {{</span>
<span class="s2">        bOld[i] = b[i];</span>
<span class="s2">        eOld[i] = e[i];</span>
<span class="s2">    }}</span>
<span class="s2">    for (int i=0; i&lt;ns; i++) {{</span>
<span class="s2">        sOld[i] = s[i];</span>
<span class="s2">        for (int j=0; j&lt;ns; j++) invd2gds2Old[i][j] = invd2gds2[i][j];</span>
<span class="s2">    }}</span>
<span class="s2">    gsl_multiroot_fdfsolver_free (soln);</span>
<span class="s2">    return TRUE;</span>
<span class="s2">}}</span>
<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_speciation_ordering_code_template_c</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C language implementation of create_speciation_ordering_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>

<span class="s2">static void order_dsdn(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="si">{ORDER_CODE_BLOCK_FIVE}</span><span class="s2"></span>
<span class="s2">    int i,j,k;</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_dsdt(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdt[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    int i,j;</span>
<span class="si">{ORDER_CODE_BLOCK_SIX}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_dsdp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double dsdp[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    int i,j;</span>
<span class="si">{ORDER_CODE_BLOCK_SEVEN}</span><span class="s2"></span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdn2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdn2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m, o;</span>
<span class="si">{ORDER_CODE_BLOCK_EIGHT}</span><span class="s2"></span>
<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">        dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdn2 cube */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NC}</span><span class="s2">; k++) {{</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[l] = d3gdn2ds[j][k][l];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) {{</span>
<span class="s2">                        temp[l] += d3gdnds2[j][l][m]*dsdn[m][k]</span>
<span class="s2">                        + d3gdnds2[k][l][m]*dsdn[m][j];</span>
<span class="s2">                        for (o=0; o&lt;</span><span class="si">{NS}</span><span class="s2">; o++)</span>
<span class="s2">                            temp[l] += d3gds3[l][m][o]*dsdn[m][j]*dsdn[o][k];</span>
<span class="s2">                    }}</span>
<span class="s2">                }}</span>
<span class="s2">                d2sdn2[i][j][k] = 0.0;</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) d2sdn2[i][j][k] += - invd2gds2[i][l]*temp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdndt(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdndt[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], dsdt[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m;</span>
<span class="si">{ORDER_CODE_BLOCK_NINE}</span><span class="s2"></span>

<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdndt matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[k] = d3gdndsdt[j][k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[k] += d3gdnds2[j][k][l]*dsdt[l] + d3gds2dt[k][l]*dsdn[l][j];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) temp[k] += d3gds3[k][l][m]*dsdn[l][j]*dsdt[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            d2sdndt[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) d2sdndt[i][j] += - invd2gds2[i][k]*temp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdndp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdndp[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdn[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NC}</span><span class="s2">], dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l, m;</span>
<span class="si">{ORDER_CODE_BLOCK_TEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdn matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            dsdn[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) dsdn[i][j] += - invd2gds2[i][k]*d2gdnds[j][k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdndp matrix */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NC}</span><span class="s2">; j++) {{</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[k] = d3gdndsdp[j][k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) {{</span>
<span class="s2">                    temp[k] += d3gdnds2[j][k][l]*dsdp[l] + d3gds2dp[k][l]*dsdn[l][j];</span>
<span class="s2">                    for (m=0; m&lt;</span><span class="si">{NS}</span><span class="s2">; m++) temp[k] += d3gds3[k][l][m]*dsdn[l][j]*dsdp[m];</span>
<span class="s2">                }}</span>
<span class="s2">            }}</span>
<span class="s2">            d2sdndp[i][j] = 0.0;</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) d2sdndp[i][j] += - invd2gds2[i][k]*temp[k];</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdt2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdt2[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdt[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_ELEVEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdt2 vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdt2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] +=  2.0*d3gds2dt[j][k]*dsdt[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdt[k]*dsdt[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdt2[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdt2[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdtdp(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdtdp[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdt[</span><span class="si">{NS}</span><span class="s2">], dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_TWELVE}</span><span class="s2"></span>

<span class="s2">    /* compute dsdt vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdt[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdt[i] += - invd2gds2[i][j]*d2gdsdt[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdtdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdtdp[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] += d3gds2dt[j][k]*dsdp[k] + d3gds2dp[j][k]*dsdt[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdt[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdtdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdtdp[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="s2">static void order_d2sdp2(double T, double P, double n[</span><span class="si">{NC}</span><span class="s2">], double b[</span><span class="si">{NC}</span><span class="s2">],</span>
<span class="s2">    double s[</span><span class="si">{NS}</span><span class="s2">], double invd2gds2[</span><span class="si">{NS}</span><span class="s2">][</span><span class="si">{NS}</span><span class="s2">], double d2sdp2[</span><span class="si">{NS}</span><span class="s2">]) {{</span>
<span class="s2">    double dsdp[</span><span class="si">{NS}</span><span class="s2">], temp[</span><span class="si">{NS}</span><span class="s2">];</span>
<span class="s2">    int i, j, k, l;</span>
<span class="si">{ORDER_CODE_BLOCK_THIRTEEN}</span><span class="s2"></span>

<span class="s2">    /* compute dsdp vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        dsdp[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) dsdp[i] += - invd2gds2[i][j]*d2gdsdp[j];</span>
<span class="s2">    }}</span>

<span class="s2">    /* compute d2sdp2 vector */</span>
<span class="s2">    for (i=0; i&lt;</span><span class="si">{NS}</span><span class="s2">; i++) {{</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) {{</span>
<span class="s2">            temp[j] = d3gdsdp2[j];</span>
<span class="s2">            for (k=0; k&lt;</span><span class="si">{NS}</span><span class="s2">; k++) {{</span>
<span class="s2">                temp[j] +=  2.0*d3gds2dp[j][k]*dsdp[k];</span>
<span class="s2">                for (l=0; l&lt;</span><span class="si">{NS}</span><span class="s2">; l++) temp[j] += d3gds3[j][k][l]*dsdp[k]*dsdp[l];</span>
<span class="s2">            }}</span>
<span class="s2">        }}</span>
<span class="s2">        d2sdp2[i] = 0.0;</span>
<span class="s2">        for (j=0; j&lt;</span><span class="si">{NS}</span><span class="s2">; j++) d2sdp2[i] += - invd2gds2[i][j]*temp[j];</span>
<span class="s2">    }}</span>
<span class="s2">}}</span>

<span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1">#######################</span>
<span class="c1"># C++ implementations #</span>
<span class="c1">#######################</span>

<span class="k">def</span> <span class="nf">_create_calib_c_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_calib_c_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_calib_h_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_calib_h_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_calib_pyx_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_calib_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_born_functions_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_code_for_born_functions()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_debye_function_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_code_for_debye_function()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_code_for_dh_functions_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_code_for_dh_functions()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_c_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_fast_c_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_h_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_fast_h_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_fast_pyx_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_fast_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_pyxbld_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_pyxbld_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_redundant_calib_TV_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_redundant_calib_TV_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_redundant_function_template_cpp</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;TP&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_redundant_function_template()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_type: string</span>
<span class="sd">        Potential type, either Gibbs free energy (&#39;TP&#39;) or Helmholtz free</span>
<span class="sd">        energy (&#39;TV&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calc_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calc_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_code_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calib_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_extra_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calib_extra_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_include_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calib_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_pyx_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calib_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_calib_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_calib_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_deriv_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_deriv_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_code_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_fast_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_include_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_fast_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_fast_pyx_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_fast_pyx_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_pyxbld_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_pyxbld_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_redun_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_deriv_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_soln_std_state_include_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_soln_std_state_include_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_ordering_gaussj_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_ordering_gaussj_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_ordering_code_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_ordering_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_complx_soln_calc_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_complx_soln_calc_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_complx_soln_calib_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_complx_soln_calib_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_speciation_code_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_speciation_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_create_speciation_ordering_code_template_cpp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    C++ language implementation of create_speciation_ordering_code_template()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string :</span>
<span class="sd">        The template string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2020, ENKI.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.4.0.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>